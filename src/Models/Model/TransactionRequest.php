<?php
/**
 * TransactionRequest
 *
 * PHP version 8.1
 *
 * @category Class
 * @package  DeveloperayoFireblocksLaravel
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Fireblocks API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.7.5
 * Contact: support@fireblocks.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.14.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace DeveloperayoFireblocksLaravel\Model;

use \ArrayAccess;
use \DeveloperayoFireblocksLaravel\ObjectSerializer;

/**
 * TransactionRequest Class Doc Comment
 *
 * @category Class
 * @package  DeveloperayoFireblocksLaravel
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class TransactionRequest implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'TransactionRequest';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'operation' => '\DeveloperayoFireblocksLaravel\Model\TransactionOperation',
        'note' => 'string',
        'external_tx_id' => 'string',
        'asset_id' => 'string',
        'source' => '\DeveloperayoFireblocksLaravel\Model\TransferPeerPath',
        'destination' => '\DeveloperayoFireblocksLaravel\Model\DestinationTransferPeerPath',
        'destinations' => '\DeveloperayoFireblocksLaravel\Model\TransactionRequestDestination[]',
        'amount' => '\DeveloperayoFireblocksLaravel\Model\TransactionRequestAmount',
        'treat_as_gross_amount' => 'bool',
        'extra_parameters' => '\DeveloperayoFireblocksLaravel\Model\ExtraParameters',
        'force_sweep' => 'bool',
        'fee_level' => 'string',
        'fee' => '\DeveloperayoFireblocksLaravel\Model\TransactionRequestFee',
        'priority_fee' => '\DeveloperayoFireblocksLaravel\Model\TransactionRequestPriorityFee',
        'fail_on_low_fee' => 'bool',
        'max_fee' => 'string',
        'gas_limit' => '\DeveloperayoFireblocksLaravel\Model\TransactionRequestGasLimit',
        'gas_price' => '\DeveloperayoFireblocksLaravel\Model\TransactionRequestGasPrice',
        'network_fee' => '\DeveloperayoFireblocksLaravel\Model\TransactionRequestNetworkFee',
        'replace_tx_by_hash' => 'string',
        'customer_ref_id' => 'string',
        'auto_staking' => 'bool',
        'network_staking' => '\DeveloperayoFireblocksLaravel\Model\TransactionRequestNetworkStaking',
        'cpu_staking' => '\DeveloperayoFireblocksLaravel\Model\TransactionRequestNetworkStaking'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'operation' => null,
        'note' => null,
        'external_tx_id' => null,
        'asset_id' => null,
        'source' => null,
        'destination' => null,
        'destinations' => null,
        'amount' => null,
        'treat_as_gross_amount' => null,
        'extra_parameters' => null,
        'force_sweep' => null,
        'fee_level' => null,
        'fee' => null,
        'priority_fee' => null,
        'fail_on_low_fee' => null,
        'max_fee' => null,
        'gas_limit' => null,
        'gas_price' => null,
        'network_fee' => null,
        'replace_tx_by_hash' => null,
        'customer_ref_id' => null,
        'auto_staking' => null,
        'network_staking' => null,
        'cpu_staking' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'operation' => false,
        'note' => false,
        'external_tx_id' => false,
        'asset_id' => false,
        'source' => false,
        'destination' => false,
        'destinations' => false,
        'amount' => false,
        'treat_as_gross_amount' => false,
        'extra_parameters' => false,
        'force_sweep' => false,
        'fee_level' => false,
        'fee' => false,
        'priority_fee' => false,
        'fail_on_low_fee' => false,
        'max_fee' => false,
        'gas_limit' => false,
        'gas_price' => false,
        'network_fee' => false,
        'replace_tx_by_hash' => false,
        'customer_ref_id' => false,
        'auto_staking' => false,
        'network_staking' => false,
        'cpu_staking' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'operation' => 'operation',
        'note' => 'note',
        'external_tx_id' => 'externalTxId',
        'asset_id' => 'assetId',
        'source' => 'source',
        'destination' => 'destination',
        'destinations' => 'destinations',
        'amount' => 'amount',
        'treat_as_gross_amount' => 'treatAsGrossAmount',
        'extra_parameters' => 'extraParameters',
        'force_sweep' => 'forceSweep',
        'fee_level' => 'feeLevel',
        'fee' => 'fee',
        'priority_fee' => 'priorityFee',
        'fail_on_low_fee' => 'failOnLowFee',
        'max_fee' => 'maxFee',
        'gas_limit' => 'gasLimit',
        'gas_price' => 'gasPrice',
        'network_fee' => 'networkFee',
        'replace_tx_by_hash' => 'replaceTxByHash',
        'customer_ref_id' => 'customerRefId',
        'auto_staking' => 'autoStaking',
        'network_staking' => 'networkStaking',
        'cpu_staking' => 'cpuStaking'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'operation' => 'setOperation',
        'note' => 'setNote',
        'external_tx_id' => 'setExternalTxId',
        'asset_id' => 'setAssetId',
        'source' => 'setSource',
        'destination' => 'setDestination',
        'destinations' => 'setDestinations',
        'amount' => 'setAmount',
        'treat_as_gross_amount' => 'setTreatAsGrossAmount',
        'extra_parameters' => 'setExtraParameters',
        'force_sweep' => 'setForceSweep',
        'fee_level' => 'setFeeLevel',
        'fee' => 'setFee',
        'priority_fee' => 'setPriorityFee',
        'fail_on_low_fee' => 'setFailOnLowFee',
        'max_fee' => 'setMaxFee',
        'gas_limit' => 'setGasLimit',
        'gas_price' => 'setGasPrice',
        'network_fee' => 'setNetworkFee',
        'replace_tx_by_hash' => 'setReplaceTxByHash',
        'customer_ref_id' => 'setCustomerRefId',
        'auto_staking' => 'setAutoStaking',
        'network_staking' => 'setNetworkStaking',
        'cpu_staking' => 'setCpuStaking'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'operation' => 'getOperation',
        'note' => 'getNote',
        'external_tx_id' => 'getExternalTxId',
        'asset_id' => 'getAssetId',
        'source' => 'getSource',
        'destination' => 'getDestination',
        'destinations' => 'getDestinations',
        'amount' => 'getAmount',
        'treat_as_gross_amount' => 'getTreatAsGrossAmount',
        'extra_parameters' => 'getExtraParameters',
        'force_sweep' => 'getForceSweep',
        'fee_level' => 'getFeeLevel',
        'fee' => 'getFee',
        'priority_fee' => 'getPriorityFee',
        'fail_on_low_fee' => 'getFailOnLowFee',
        'max_fee' => 'getMaxFee',
        'gas_limit' => 'getGasLimit',
        'gas_price' => 'getGasPrice',
        'network_fee' => 'getNetworkFee',
        'replace_tx_by_hash' => 'getReplaceTxByHash',
        'customer_ref_id' => 'getCustomerRefId',
        'auto_staking' => 'getAutoStaking',
        'network_staking' => 'getNetworkStaking',
        'cpu_staking' => 'getCpuStaking'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const FEE_LEVEL_LOW = 'LOW';
    public const FEE_LEVEL_MEDIUM = 'MEDIUM';
    public const FEE_LEVEL_HIGH = 'HIGH';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getFeeLevelAllowableValues()
    {
        return [
            self::FEE_LEVEL_LOW,
            self::FEE_LEVEL_MEDIUM,
            self::FEE_LEVEL_HIGH,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[]|null $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('operation', $data ?? [], null);
        $this->setIfExists('note', $data ?? [], null);
        $this->setIfExists('external_tx_id', $data ?? [], null);
        $this->setIfExists('asset_id', $data ?? [], null);
        $this->setIfExists('source', $data ?? [], null);
        $this->setIfExists('destination', $data ?? [], null);
        $this->setIfExists('destinations', $data ?? [], null);
        $this->setIfExists('amount', $data ?? [], null);
        $this->setIfExists('treat_as_gross_amount', $data ?? [], null);
        $this->setIfExists('extra_parameters', $data ?? [], null);
        $this->setIfExists('force_sweep', $data ?? [], null);
        $this->setIfExists('fee_level', $data ?? [], null);
        $this->setIfExists('fee', $data ?? [], null);
        $this->setIfExists('priority_fee', $data ?? [], null);
        $this->setIfExists('fail_on_low_fee', $data ?? [], null);
        $this->setIfExists('max_fee', $data ?? [], null);
        $this->setIfExists('gas_limit', $data ?? [], null);
        $this->setIfExists('gas_price', $data ?? [], null);
        $this->setIfExists('network_fee', $data ?? [], null);
        $this->setIfExists('replace_tx_by_hash', $data ?? [], null);
        $this->setIfExists('customer_ref_id', $data ?? [], null);
        $this->setIfExists('auto_staking', $data ?? [], null);
        $this->setIfExists('network_staking', $data ?? [], null);
        $this->setIfExists('cpu_staking', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getFeeLevelAllowableValues();
        if (!is_null($this->container['fee_level']) && !in_array($this->container['fee_level'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'fee_level', must be one of '%s'",
                $this->container['fee_level'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets operation
     *
     * @return \DeveloperayoFireblocksLaravel\Model\TransactionOperation|null
     */
    public function getOperation()
    {
        return $this->container['operation'];
    }

    /**
     * Sets operation
     *
     * @param \DeveloperayoFireblocksLaravel\Model\TransactionOperation|null $operation operation
     *
     * @return self
     */
    public function setOperation($operation)
    {
        if (is_null($operation)) {
            throw new \InvalidArgumentException('non-nullable operation cannot be null');
        }
        $this->container['operation'] = $operation;

        return $this;
    }

    /**
     * Gets note
     *
     * @return string|null
     */
    public function getNote()
    {
        return $this->container['note'];
    }

    /**
     * Sets note
     *
     * @param string|null $note Custom note, not sent to the blockchain, to describe the transaction at your Fireblocks workspace.
     *
     * @return self
     */
    public function setNote($note)
    {
        if (is_null($note)) {
            throw new \InvalidArgumentException('non-nullable note cannot be null');
        }
        $this->container['note'] = $note;

        return $this;
    }

    /**
     * Gets external_tx_id
     *
     * @return string|null
     */
    public function getExternalTxId()
    {
        return $this->container['external_tx_id'];
    }

    /**
     * Sets external_tx_id
     *
     * @param string|null $external_tx_id An optional but highly recommended parameter. Fireblocks will reject future transactions with same ID.    You should set this to a unique ID representing the transaction, to avoid submitting the same transaction twice. This helps with cases where submitting the transaction responds with an error code due to Internet interruptions, but the transaction was actually sent and processed. To validate whether a transaction has been processed, [Find a specific transaction by external transaction ID](https://developers.fireblocks.com/reference/get_transactions-external-tx-id-externaltxid).   There is no specific format required for this parameter.
     *
     * @return self
     */
    public function setExternalTxId($external_tx_id)
    {
        if (is_null($external_tx_id)) {
            throw new \InvalidArgumentException('non-nullable external_tx_id cannot be null');
        }
        $this->container['external_tx_id'] = $external_tx_id;

        return $this;
    }

    /**
     * Gets asset_id
     *
     * @return string|null
     */
    public function getAssetId()
    {
        return $this->container['asset_id'];
    }

    /**
     * Sets asset_id
     *
     * @param string|null $asset_id The ID of the asset to transfer, for `TRANSFER`, `MINT` or `BURN` operations. [See the list of supported assets and their IDs on Fireblocks.](https://developers.fireblocks.com/reference/get_supported-assets)
     *
     * @return self
     */
    public function setAssetId($asset_id)
    {
        if (is_null($asset_id)) {
            throw new \InvalidArgumentException('non-nullable asset_id cannot be null');
        }
        $this->container['asset_id'] = $asset_id;

        return $this;
    }

    /**
     * Gets source
     *
     * @return \DeveloperayoFireblocksLaravel\Model\TransferPeerPath|null
     */
    public function getSource()
    {
        return $this->container['source'];
    }

    /**
     * Sets source
     *
     * @param \DeveloperayoFireblocksLaravel\Model\TransferPeerPath|null $source source
     *
     * @return self
     */
    public function setSource($source)
    {
        if (is_null($source)) {
            throw new \InvalidArgumentException('non-nullable source cannot be null');
        }
        $this->container['source'] = $source;

        return $this;
    }

    /**
     * Gets destination
     *
     * @return \DeveloperayoFireblocksLaravel\Model\DestinationTransferPeerPath|null
     */
    public function getDestination()
    {
        return $this->container['destination'];
    }

    /**
     * Sets destination
     *
     * @param \DeveloperayoFireblocksLaravel\Model\DestinationTransferPeerPath|null $destination destination
     *
     * @return self
     */
    public function setDestination($destination)
    {
        if (is_null($destination)) {
            throw new \InvalidArgumentException('non-nullable destination cannot be null');
        }
        $this->container['destination'] = $destination;

        return $this;
    }

    /**
     * Gets destinations
     *
     * @return \DeveloperayoFireblocksLaravel\Model\TransactionRequestDestination[]|null
     */
    public function getDestinations()
    {
        return $this->container['destinations'];
    }

    /**
     * Sets destinations
     *
     * @param \DeveloperayoFireblocksLaravel\Model\TransactionRequestDestination[]|null $destinations For UTXO based blockchains, you can send a single transaction to multiple destinations.
     *
     * @return self
     */
    public function setDestinations($destinations)
    {
        if (is_null($destinations)) {
            throw new \InvalidArgumentException('non-nullable destinations cannot be null');
        }
        $this->container['destinations'] = $destinations;

        return $this;
    }

    /**
     * Gets amount
     *
     * @return \DeveloperayoFireblocksLaravel\Model\TransactionRequestAmount|null
     */
    public function getAmount()
    {
        return $this->container['amount'];
    }

    /**
     * Sets amount
     *
     * @param \DeveloperayoFireblocksLaravel\Model\TransactionRequestAmount|null $amount amount
     *
     * @return self
     */
    public function setAmount($amount)
    {
        if (is_null($amount)) {
            throw new \InvalidArgumentException('non-nullable amount cannot be null');
        }
        $this->container['amount'] = $amount;

        return $this;
    }

    /**
     * Gets treat_as_gross_amount
     *
     * @return bool|null
     */
    public function getTreatAsGrossAmount()
    {
        return $this->container['treat_as_gross_amount'];
    }

    /**
     * Sets treat_as_gross_amount
     *
     * @param bool|null $treat_as_gross_amount \"When set to `true`, the fee will be deducted from the requested amount.\"  **Note**: This parameter can only be considered if a transaction’s asset is a base asset, such as ETH or MATIC. If the asset can’t be used for transaction fees, like USDC, this parameter is ignored and the fee is deducted from the relevant base asset wallet in the source account.
     *
     * @return self
     */
    public function setTreatAsGrossAmount($treat_as_gross_amount)
    {
        if (is_null($treat_as_gross_amount)) {
            throw new \InvalidArgumentException('non-nullable treat_as_gross_amount cannot be null');
        }
        $this->container['treat_as_gross_amount'] = $treat_as_gross_amount;

        return $this;
    }

    /**
     * Gets extra_parameters
     *
     * @return \DeveloperayoFireblocksLaravel\Model\ExtraParameters|null
     */
    public function getExtraParameters()
    {
        return $this->container['extra_parameters'];
    }

    /**
     * Sets extra_parameters
     *
     * @param \DeveloperayoFireblocksLaravel\Model\ExtraParameters|null $extra_parameters extra_parameters
     *
     * @return self
     */
    public function setExtraParameters($extra_parameters)
    {
        if (is_null($extra_parameters)) {
            throw new \InvalidArgumentException('non-nullable extra_parameters cannot be null');
        }
        $this->container['extra_parameters'] = $extra_parameters;

        return $this;
    }

    /**
     * Gets force_sweep
     *
     * @return bool|null
     */
    public function getForceSweep()
    {
        return $this->container['force_sweep'];
    }

    /**
     * Sets force_sweep
     *
     * @param bool|null $force_sweep For Polkadot, Kusama and Westend transactions only. When set to true, Fireblocks will empty the asset wallet.     **Note:** If set to true when the source account is exactly 1 DOT, the transaction will fail. Any amount more or less than 1 DOT succeeds. This is a Polkadot blockchain limitation.
     *
     * @return self
     */
    public function setForceSweep($force_sweep)
    {
        if (is_null($force_sweep)) {
            throw new \InvalidArgumentException('non-nullable force_sweep cannot be null');
        }
        $this->container['force_sweep'] = $force_sweep;

        return $this;
    }

    /**
     * Gets fee_level
     *
     * @return string|null
     */
    public function getFeeLevel()
    {
        return $this->container['fee_level'];
    }

    /**
     * Sets fee_level
     *
     * @param string|null $fee_level For UTXO or EVM-based blockchains only. Defines the blockchain fee level which will be payed for the transaction. Alternatively, specific fee estimation parameters exist below.
     *
     * @return self
     */
    public function setFeeLevel($fee_level)
    {
        if (is_null($fee_level)) {
            throw new \InvalidArgumentException('non-nullable fee_level cannot be null');
        }
        $allowedValues = $this->getFeeLevelAllowableValues();
        if (!in_array($fee_level, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'fee_level', must be one of '%s'",
                    $fee_level,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['fee_level'] = $fee_level;

        return $this;
    }

    /**
     * Gets fee
     *
     * @return \DeveloperayoFireblocksLaravel\Model\TransactionRequestFee|null
     */
    public function getFee()
    {
        return $this->container['fee'];
    }

    /**
     * Sets fee
     *
     * @param \DeveloperayoFireblocksLaravel\Model\TransactionRequestFee|null $fee fee
     *
     * @return self
     */
    public function setFee($fee)
    {
        if (is_null($fee)) {
            throw new \InvalidArgumentException('non-nullable fee cannot be null');
        }
        $this->container['fee'] = $fee;

        return $this;
    }

    /**
     * Gets priority_fee
     *
     * @return \DeveloperayoFireblocksLaravel\Model\TransactionRequestPriorityFee|null
     */
    public function getPriorityFee()
    {
        return $this->container['priority_fee'];
    }

    /**
     * Sets priority_fee
     *
     * @param \DeveloperayoFireblocksLaravel\Model\TransactionRequestPriorityFee|null $priority_fee priority_fee
     *
     * @return self
     */
    public function setPriorityFee($priority_fee)
    {
        if (is_null($priority_fee)) {
            throw new \InvalidArgumentException('non-nullable priority_fee cannot be null');
        }
        $this->container['priority_fee'] = $priority_fee;

        return $this;
    }

    /**
     * Gets fail_on_low_fee
     *
     * @return bool|null
     */
    public function getFailOnLowFee()
    {
        return $this->container['fail_on_low_fee'];
    }

    /**
     * Sets fail_on_low_fee
     *
     * @param bool|null $fail_on_low_fee When set to `true`, in case the current `MEDIUM` fee level is higher than the one specified in the transaction, the transaction will fail to avoid getting stuck with no confirmations.
     *
     * @return self
     */
    public function setFailOnLowFee($fail_on_low_fee)
    {
        if (is_null($fail_on_low_fee)) {
            throw new \InvalidArgumentException('non-nullable fail_on_low_fee cannot be null');
        }
        $this->container['fail_on_low_fee'] = $fail_on_low_fee;

        return $this;
    }

    /**
     * Gets max_fee
     *
     * @return string|null
     */
    public function getMaxFee()
    {
        return $this->container['max_fee'];
    }

    /**
     * Sets max_fee
     *
     * @param string|null $max_fee The maximum fee (gas price or fee per byte) that should be payed for the transaction.  In case the current value of the requested `feeLevel` is higher than this requested maximum fee.  Represented by a numeric string for accurate precision.
     *
     * @return self
     */
    public function setMaxFee($max_fee)
    {
        if (is_null($max_fee)) {
            throw new \InvalidArgumentException('non-nullable max_fee cannot be null');
        }
        $this->container['max_fee'] = $max_fee;

        return $this;
    }

    /**
     * Gets gas_limit
     *
     * @return \DeveloperayoFireblocksLaravel\Model\TransactionRequestGasLimit|null
     */
    public function getGasLimit()
    {
        return $this->container['gas_limit'];
    }

    /**
     * Sets gas_limit
     *
     * @param \DeveloperayoFireblocksLaravel\Model\TransactionRequestGasLimit|null $gas_limit gas_limit
     *
     * @return self
     */
    public function setGasLimit($gas_limit)
    {
        if (is_null($gas_limit)) {
            throw new \InvalidArgumentException('non-nullable gas_limit cannot be null');
        }
        $this->container['gas_limit'] = $gas_limit;

        return $this;
    }

    /**
     * Gets gas_price
     *
     * @return \DeveloperayoFireblocksLaravel\Model\TransactionRequestGasPrice|null
     */
    public function getGasPrice()
    {
        return $this->container['gas_price'];
    }

    /**
     * Sets gas_price
     *
     * @param \DeveloperayoFireblocksLaravel\Model\TransactionRequestGasPrice|null $gas_price gas_price
     *
     * @return self
     */
    public function setGasPrice($gas_price)
    {
        if (is_null($gas_price)) {
            throw new \InvalidArgumentException('non-nullable gas_price cannot be null');
        }
        $this->container['gas_price'] = $gas_price;

        return $this;
    }

    /**
     * Gets network_fee
     *
     * @return \DeveloperayoFireblocksLaravel\Model\TransactionRequestNetworkFee|null
     */
    public function getNetworkFee()
    {
        return $this->container['network_fee'];
    }

    /**
     * Sets network_fee
     *
     * @param \DeveloperayoFireblocksLaravel\Model\TransactionRequestNetworkFee|null $network_fee network_fee
     *
     * @return self
     */
    public function setNetworkFee($network_fee)
    {
        if (is_null($network_fee)) {
            throw new \InvalidArgumentException('non-nullable network_fee cannot be null');
        }
        $this->container['network_fee'] = $network_fee;

        return $this;
    }

    /**
     * Gets replace_tx_by_hash
     *
     * @return string|null
     */
    public function getReplaceTxByHash()
    {
        return $this->container['replace_tx_by_hash'];
    }

    /**
     * Sets replace_tx_by_hash
     *
     * @param string|null $replace_tx_by_hash For EVM-based blockchains only. In case a transaction is stuck, specify the hash of the stuck transaction to replace it by this transaction with a higher fee, or to replace it with this transaction with a zero fee and drop it from the blockchain.
     *
     * @return self
     */
    public function setReplaceTxByHash($replace_tx_by_hash)
    {
        if (is_null($replace_tx_by_hash)) {
            throw new \InvalidArgumentException('non-nullable replace_tx_by_hash cannot be null');
        }
        $this->container['replace_tx_by_hash'] = $replace_tx_by_hash;

        return $this;
    }

    /**
     * Gets customer_ref_id
     *
     * @return string|null
     */
    public function getCustomerRefId()
    {
        return $this->container['customer_ref_id'];
    }

    /**
     * Sets customer_ref_id
     *
     * @param string|null $customer_ref_id The ID for AML providers to associate the owner of funds with transactions.
     *
     * @return self
     */
    public function setCustomerRefId($customer_ref_id)
    {
        if (is_null($customer_ref_id)) {
            throw new \InvalidArgumentException('non-nullable customer_ref_id cannot be null');
        }
        $this->container['customer_ref_id'] = $customer_ref_id;

        return $this;
    }

    /**
     * Gets auto_staking
     *
     * @return bool|null
     * @deprecated
     */
    public function getAutoStaking()
    {
        return $this->container['auto_staking'];
    }

    /**
     * Sets auto_staking
     *
     * @param bool|null $auto_staking This feature is no longer supported.
     *
     * @return self
     * @deprecated
     */
    public function setAutoStaking($auto_staking)
    {
        if (is_null($auto_staking)) {
            throw new \InvalidArgumentException('non-nullable auto_staking cannot be null');
        }
        $this->container['auto_staking'] = $auto_staking;

        return $this;
    }

    /**
     * Gets network_staking
     *
     * @return \DeveloperayoFireblocksLaravel\Model\TransactionRequestNetworkStaking|null
     * @deprecated
     */
    public function getNetworkStaking()
    {
        return $this->container['network_staking'];
    }

    /**
     * Sets network_staking
     *
     * @param \DeveloperayoFireblocksLaravel\Model\TransactionRequestNetworkStaking|null $network_staking network_staking
     *
     * @return self
     * @deprecated
     */
    public function setNetworkStaking($network_staking)
    {
        if (is_null($network_staking)) {
            throw new \InvalidArgumentException('non-nullable network_staking cannot be null');
        }
        $this->container['network_staking'] = $network_staking;

        return $this;
    }

    /**
     * Gets cpu_staking
     *
     * @return \DeveloperayoFireblocksLaravel\Model\TransactionRequestNetworkStaking|null
     * @deprecated
     */
    public function getCpuStaking()
    {
        return $this->container['cpu_staking'];
    }

    /**
     * Sets cpu_staking
     *
     * @param \DeveloperayoFireblocksLaravel\Model\TransactionRequestNetworkStaking|null $cpu_staking cpu_staking
     *
     * @return self
     * @deprecated
     */
    public function setCpuStaking($cpu_staking)
    {
        if (is_null($cpu_staking)) {
            throw new \InvalidArgumentException('non-nullable cpu_staking cannot be null');
        }
        $this->container['cpu_staking'] = $cpu_staking;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


