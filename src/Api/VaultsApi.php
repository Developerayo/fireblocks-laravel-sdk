<?php
/**
 * VaultsApi
 * PHP version 8.1
 *
 * @category Class
 * @package  Developerayo\FireblocksLaravel
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Fireblocks API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.7.5
 * Contact: support@fireblocks.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.14.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Developerayo\FireblocksLaravel\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use Developerayo\FireblocksLaravel\ApiException;
use Developerayo\FireblocksLaravel\Configuration;
use Developerayo\FireblocksLaravel\FormDataProcessor;
use Developerayo\FireblocksLaravel\HeaderSelector;
use Developerayo\FireblocksLaravel\ObjectSerializer;

/**
 * VaultsApi Class Doc Comment
 *
 * @category Class
 * @package  Developerayo\FireblocksLaravel
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class VaultsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'createVaultAccountAssetAddress' => [
            'application/json',
        ],
        'vaultAccountsGet' => [
            'application/json',
        ],
        'vaultAccountsPagedGet' => [
            'application/json',
        ],
        'vaultAccountsPost' => [
            'application/json',
        ],
        'vaultAccountsVaultAccountIdAssetIdActivatePost' => [
            'application/json',
        ],
        'vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPost' => [
            'application/json',
        ],
        'vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPut' => [
            'application/json',
        ],
        'vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPost' => [
            'application/json',
        ],
        'vaultAccountsVaultAccountIdAssetIdAddressesGet' => [
            'application/json',
        ],
        'vaultAccountsVaultAccountIdAssetIdAddressesPaginatedGet' => [
            'application/json',
        ],
        'vaultAccountsVaultAccountIdAssetIdBalancePost' => [
            'application/json',
        ],
        'vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGet' => [
            'application/json',
        ],
        'vaultAccountsVaultAccountIdAssetIdGet' => [
            'application/json',
        ],
        'vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGet' => [
            'application/json',
        ],
        'vaultAccountsVaultAccountIdAssetIdPost' => [
            'application/json',
        ],
        'vaultAccountsVaultAccountIdAssetIdUnspentInputsGet' => [
            'application/json',
        ],
        'vaultAccountsVaultAccountIdGet' => [
            'application/json',
        ],
        'vaultAccountsVaultAccountIdHidePost' => [
            'application/json',
        ],
        'vaultAccountsVaultAccountIdPut' => [
            'application/json',
        ],
        'vaultAccountsVaultAccountIdSetAutoFuelPost' => [
            'application/json',
        ],
        'vaultAccountsVaultAccountIdSetCustomerRefIdPost' => [
            'application/json',
        ],
        'vaultAccountsVaultAccountIdUnhidePost' => [
            'application/json',
        ],
        'vaultAssetWalletsGet' => [
            'application/json',
        ],
        'vaultAssetsAssetIdGet' => [
            'application/json',
        ],
        'vaultAssetsGet' => [
            'application/json',
        ],
        'vaultPublicKeyInfoGet' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createVaultAccountAssetAddress
     *
     * Create new asset deposit address
     *
     * @param  string $vaultAccountId The ID of the vault account to return (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  \Developerayo\FireblocksLaravel\Models\CreateVaultAccountAssetAddressRequest|null $createVaultAccountAssetAddressRequest createVaultAccountAssetAddressRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVaultAccountAssetAddress'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Developerayo\FireblocksLaravel\Models\CreateAddressResponse|\Developerayo\FireblocksLaravel\Models\Error
     */
    public function createVaultAccountAssetAddress($vaultAccountId, $assetId, $createVaultAccountAssetAddressRequest = null, string $contentType = self::contentTypes['createVaultAccountAssetAddress'][0])
    {
        list($response) = $this->createVaultAccountAssetAddressWithHttpInfo($vaultAccountId, $assetId, $createVaultAccountAssetAddressRequest, $contentType);
        return $response;
    }

    /**
     * Operation createVaultAccountAssetAddressWithHttpInfo
     *
     * Create new asset deposit address
     *
     * @param  string $vaultAccountId The ID of the vault account to return (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  \Developerayo\FireblocksLaravel\Models\CreateVaultAccountAssetAddressRequest|null $createVaultAccountAssetAddressRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVaultAccountAssetAddress'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Developerayo\FireblocksLaravel\Models\CreateAddressResponse|\Developerayo\FireblocksLaravel\Models\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createVaultAccountAssetAddressWithHttpInfo($vaultAccountId, $assetId, $createVaultAccountAssetAddressRequest = null, string $contentType = self::contentTypes['createVaultAccountAssetAddress'][0])
    {
        $request = $this->createVaultAccountAssetAddressRequest($vaultAccountId, $assetId, $createVaultAccountAssetAddressRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\CreateAddressResponse',
                        $request,
                        $response,
                    );
                default:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Developerayo\FireblocksLaravel\Models\CreateAddressResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\CreateAddressResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createVaultAccountAssetAddressAsync
     *
     * Create new asset deposit address
     *
     * @param  string $vaultAccountId The ID of the vault account to return (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  \Developerayo\FireblocksLaravel\Models\CreateVaultAccountAssetAddressRequest|null $createVaultAccountAssetAddressRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVaultAccountAssetAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createVaultAccountAssetAddressAsync($vaultAccountId, $assetId, $createVaultAccountAssetAddressRequest = null, string $contentType = self::contentTypes['createVaultAccountAssetAddress'][0])
    {
        return $this->createVaultAccountAssetAddressAsyncWithHttpInfo($vaultAccountId, $assetId, $createVaultAccountAssetAddressRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createVaultAccountAssetAddressAsyncWithHttpInfo
     *
     * Create new asset deposit address
     *
     * @param  string $vaultAccountId The ID of the vault account to return (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  \Developerayo\FireblocksLaravel\Models\CreateVaultAccountAssetAddressRequest|null $createVaultAccountAssetAddressRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVaultAccountAssetAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createVaultAccountAssetAddressAsyncWithHttpInfo($vaultAccountId, $assetId, $createVaultAccountAssetAddressRequest = null, string $contentType = self::contentTypes['createVaultAccountAssetAddress'][0])
    {
        $returnType = '\Developerayo\FireblocksLaravel\Models\CreateAddressResponse';
        $request = $this->createVaultAccountAssetAddressRequest($vaultAccountId, $assetId, $createVaultAccountAssetAddressRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createVaultAccountAssetAddress'
     *
     * @param  string $vaultAccountId The ID of the vault account to return (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  \Developerayo\FireblocksLaravel\Models\CreateVaultAccountAssetAddressRequest|null $createVaultAccountAssetAddressRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVaultAccountAssetAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createVaultAccountAssetAddressRequest($vaultAccountId, $assetId, $createVaultAccountAssetAddressRequest = null, string $contentType = self::contentTypes['createVaultAccountAssetAddress'][0])
    {

        // verify the required parameter 'vaultAccountId' is set
        if ($vaultAccountId === null || (is_array($vaultAccountId) && count($vaultAccountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vaultAccountId when calling createVaultAccountAssetAddress'
            );
        }

        // verify the required parameter 'assetId' is set
        if ($assetId === null || (is_array($assetId) && count($assetId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $assetId when calling createVaultAccountAssetAddress'
            );
        }



        $resourcePath = '/vault/accounts/{vaultAccountId}/{assetId}/addresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($vaultAccountId !== null) {
            $resourcePath = str_replace(
                '{' . 'vaultAccountId' . '}',
                ObjectSerializer::toPathValue($vaultAccountId),
                $resourcePath
            );
        }
        // path params
        if ($assetId !== null) {
            $resourcePath = str_replace(
                '{' . 'assetId' . '}',
                ObjectSerializer::toPathValue($assetId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createVaultAccountAssetAddressRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createVaultAccountAssetAddressRequest));
            } else {
                $httpBody = $createVaultAccountAssetAddressRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vaultAccountsGet
     *
     * List vault accounts
     *
     * @param  string|null $namePrefix namePrefix (optional)
     * @param  string|null $nameSuffix nameSuffix (optional)
     * @param  float|null $minAmountThreshold minAmountThreshold (optional)
     * @param  string|null $assetId assetId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsGet'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Developerayo\FireblocksLaravel\Models\VaultAccount[]|\Developerayo\FireblocksLaravel\Models\Error
     * @deprecated
     */
    public function vaultAccountsGet($namePrefix = null, $nameSuffix = null, $minAmountThreshold = null, $assetId = null, string $contentType = self::contentTypes['vaultAccountsGet'][0])
    {
        list($response) = $this->vaultAccountsGetWithHttpInfo($namePrefix, $nameSuffix, $minAmountThreshold, $assetId, $contentType);
        return $response;
    }

    /**
     * Operation vaultAccountsGetWithHttpInfo
     *
     * List vault accounts
     *
     * @param  string|null $namePrefix (optional)
     * @param  string|null $nameSuffix (optional)
     * @param  float|null $minAmountThreshold (optional)
     * @param  string|null $assetId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsGet'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Developerayo\FireblocksLaravel\Models\VaultAccount[]|\Developerayo\FireblocksLaravel\Models\Error, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function vaultAccountsGetWithHttpInfo($namePrefix = null, $nameSuffix = null, $minAmountThreshold = null, $assetId = null, string $contentType = self::contentTypes['vaultAccountsGet'][0])
    {
        $request = $this->vaultAccountsGetRequest($namePrefix, $nameSuffix, $minAmountThreshold, $assetId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\VaultAccount[]',
                        $request,
                        $response,
                    );
                default:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Developerayo\FireblocksLaravel\Models\VaultAccount[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\VaultAccount[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation vaultAccountsGetAsync
     *
     * List vault accounts
     *
     * @param  string|null $namePrefix (optional)
     * @param  string|null $nameSuffix (optional)
     * @param  float|null $minAmountThreshold (optional)
     * @param  string|null $assetId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function vaultAccountsGetAsync($namePrefix = null, $nameSuffix = null, $minAmountThreshold = null, $assetId = null, string $contentType = self::contentTypes['vaultAccountsGet'][0])
    {
        return $this->vaultAccountsGetAsyncWithHttpInfo($namePrefix, $nameSuffix, $minAmountThreshold, $assetId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vaultAccountsGetAsyncWithHttpInfo
     *
     * List vault accounts
     *
     * @param  string|null $namePrefix (optional)
     * @param  string|null $nameSuffix (optional)
     * @param  float|null $minAmountThreshold (optional)
     * @param  string|null $assetId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function vaultAccountsGetAsyncWithHttpInfo($namePrefix = null, $nameSuffix = null, $minAmountThreshold = null, $assetId = null, string $contentType = self::contentTypes['vaultAccountsGet'][0])
    {
        $returnType = '\Developerayo\FireblocksLaravel\Models\VaultAccount[]';
        $request = $this->vaultAccountsGetRequest($namePrefix, $nameSuffix, $minAmountThreshold, $assetId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vaultAccountsGet'
     *
     * @param  string|null $namePrefix (optional)
     * @param  string|null $nameSuffix (optional)
     * @param  float|null $minAmountThreshold (optional)
     * @param  string|null $assetId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function vaultAccountsGetRequest($namePrefix = null, $nameSuffix = null, $minAmountThreshold = null, $assetId = null, string $contentType = self::contentTypes['vaultAccountsGet'][0])
    {






        $resourcePath = '/vault/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $namePrefix,
            'namePrefix', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $nameSuffix,
            'nameSuffix', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $minAmountThreshold,
            'minAmountThreshold', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assetId,
            'assetId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vaultAccountsPagedGet
     *
     * List vault accounts (Paginated)
     *
     * @param  string|null $namePrefix namePrefix (optional)
     * @param  string|null $nameSuffix nameSuffix (optional)
     * @param  float|null $minAmountThreshold Specifying minAmountThreshold will filter accounts with balances greater than this value, otherwise, it will return all accounts. (optional)
     * @param  string|null $assetId assetId (optional)
     * @param  string|null $orderBy orderBy (optional, default to 'DESC')
     * @param  string|null $before before (optional)
     * @param  string|null $after after (optional)
     * @param  float|null $limit limit (optional, default to 200)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsPagedGet'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Developerayo\FireblocksLaravel\Models\VaultAccountsPagedResponse
     */
    public function vaultAccountsPagedGet($namePrefix = null, $nameSuffix = null, $minAmountThreshold = null, $assetId = null, $orderBy = 'DESC', $before = null, $after = null, $limit = 200, string $contentType = self::contentTypes['vaultAccountsPagedGet'][0])
    {
        list($response) = $this->vaultAccountsPagedGetWithHttpInfo($namePrefix, $nameSuffix, $minAmountThreshold, $assetId, $orderBy, $before, $after, $limit, $contentType);
        return $response;
    }

    /**
     * Operation vaultAccountsPagedGetWithHttpInfo
     *
     * List vault accounts (Paginated)
     *
     * @param  string|null $namePrefix (optional)
     * @param  string|null $nameSuffix (optional)
     * @param  float|null $minAmountThreshold Specifying minAmountThreshold will filter accounts with balances greater than this value, otherwise, it will return all accounts. (optional)
     * @param  string|null $assetId (optional)
     * @param  string|null $orderBy (optional, default to 'DESC')
     * @param  string|null $before (optional)
     * @param  string|null $after (optional)
     * @param  float|null $limit (optional, default to 200)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsPagedGet'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Developerayo\FireblocksLaravel\Models\VaultAccountsPagedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function vaultAccountsPagedGetWithHttpInfo($namePrefix = null, $nameSuffix = null, $minAmountThreshold = null, $assetId = null, $orderBy = 'DESC', $before = null, $after = null, $limit = 200, string $contentType = self::contentTypes['vaultAccountsPagedGet'][0])
    {
        $request = $this->vaultAccountsPagedGetRequest($namePrefix, $nameSuffix, $minAmountThreshold, $assetId, $orderBy, $before, $after, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\VaultAccountsPagedResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Developerayo\FireblocksLaravel\Models\VaultAccountsPagedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\VaultAccountsPagedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation vaultAccountsPagedGetAsync
     *
     * List vault accounts (Paginated)
     *
     * @param  string|null $namePrefix (optional)
     * @param  string|null $nameSuffix (optional)
     * @param  float|null $minAmountThreshold Specifying minAmountThreshold will filter accounts with balances greater than this value, otherwise, it will return all accounts. (optional)
     * @param  string|null $assetId (optional)
     * @param  string|null $orderBy (optional, default to 'DESC')
     * @param  string|null $before (optional)
     * @param  string|null $after (optional)
     * @param  float|null $limit (optional, default to 200)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsPagedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsPagedGetAsync($namePrefix = null, $nameSuffix = null, $minAmountThreshold = null, $assetId = null, $orderBy = 'DESC', $before = null, $after = null, $limit = 200, string $contentType = self::contentTypes['vaultAccountsPagedGet'][0])
    {
        return $this->vaultAccountsPagedGetAsyncWithHttpInfo($namePrefix, $nameSuffix, $minAmountThreshold, $assetId, $orderBy, $before, $after, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vaultAccountsPagedGetAsyncWithHttpInfo
     *
     * List vault accounts (Paginated)
     *
     * @param  string|null $namePrefix (optional)
     * @param  string|null $nameSuffix (optional)
     * @param  float|null $minAmountThreshold Specifying minAmountThreshold will filter accounts with balances greater than this value, otherwise, it will return all accounts. (optional)
     * @param  string|null $assetId (optional)
     * @param  string|null $orderBy (optional, default to 'DESC')
     * @param  string|null $before (optional)
     * @param  string|null $after (optional)
     * @param  float|null $limit (optional, default to 200)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsPagedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsPagedGetAsyncWithHttpInfo($namePrefix = null, $nameSuffix = null, $minAmountThreshold = null, $assetId = null, $orderBy = 'DESC', $before = null, $after = null, $limit = 200, string $contentType = self::contentTypes['vaultAccountsPagedGet'][0])
    {
        $returnType = '\Developerayo\FireblocksLaravel\Models\VaultAccountsPagedResponse';
        $request = $this->vaultAccountsPagedGetRequest($namePrefix, $nameSuffix, $minAmountThreshold, $assetId, $orderBy, $before, $after, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vaultAccountsPagedGet'
     *
     * @param  string|null $namePrefix (optional)
     * @param  string|null $nameSuffix (optional)
     * @param  float|null $minAmountThreshold Specifying minAmountThreshold will filter accounts with balances greater than this value, otherwise, it will return all accounts. (optional)
     * @param  string|null $assetId (optional)
     * @param  string|null $orderBy (optional, default to 'DESC')
     * @param  string|null $before (optional)
     * @param  string|null $after (optional)
     * @param  float|null $limit (optional, default to 200)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsPagedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vaultAccountsPagedGetRequest($namePrefix = null, $nameSuffix = null, $minAmountThreshold = null, $assetId = null, $orderBy = 'DESC', $before = null, $after = null, $limit = 200, string $contentType = self::contentTypes['vaultAccountsPagedGet'][0])
    {








        if ($limit !== null && $limit > 500) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling VaultsApi.vaultAccountsPagedGet, must be smaller than or equal to 500.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling VaultsApi.vaultAccountsPagedGet, must be bigger than or equal to 1.');
        }
        

        $resourcePath = '/vault/accounts_paged';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $namePrefix,
            'namePrefix', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $nameSuffix,
            'nameSuffix', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $minAmountThreshold,
            'minAmountThreshold', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assetId,
            'assetId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderBy,
            'orderBy', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $before,
            'before', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $after,
            'after', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vaultAccountsPost
     *
     * Create a new vault account
     *
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsPostRequest $vaultAccountsPostRequest vaultAccountsPostRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsPost'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Developerayo\FireblocksLaravel\Models\VaultAccount|\Developerayo\FireblocksLaravel\Models\Error
     */
    public function vaultAccountsPost($vaultAccountsPostRequest, string $contentType = self::contentTypes['vaultAccountsPost'][0])
    {
        list($response) = $this->vaultAccountsPostWithHttpInfo($vaultAccountsPostRequest, $contentType);
        return $response;
    }

    /**
     * Operation vaultAccountsPostWithHttpInfo
     *
     * Create a new vault account
     *
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsPostRequest $vaultAccountsPostRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsPost'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Developerayo\FireblocksLaravel\Models\VaultAccount|\Developerayo\FireblocksLaravel\Models\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function vaultAccountsPostWithHttpInfo($vaultAccountsPostRequest, string $contentType = self::contentTypes['vaultAccountsPost'][0])
    {
        $request = $this->vaultAccountsPostRequest($vaultAccountsPostRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\VaultAccount',
                        $request,
                        $response,
                    );
                default:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Developerayo\FireblocksLaravel\Models\VaultAccount',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\VaultAccount',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation vaultAccountsPostAsync
     *
     * Create a new vault account
     *
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsPostRequest $vaultAccountsPostRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsPostAsync($vaultAccountsPostRequest, string $contentType = self::contentTypes['vaultAccountsPost'][0])
    {
        return $this->vaultAccountsPostAsyncWithHttpInfo($vaultAccountsPostRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vaultAccountsPostAsyncWithHttpInfo
     *
     * Create a new vault account
     *
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsPostRequest $vaultAccountsPostRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsPostAsyncWithHttpInfo($vaultAccountsPostRequest, string $contentType = self::contentTypes['vaultAccountsPost'][0])
    {
        $returnType = '\Developerayo\FireblocksLaravel\Models\VaultAccount';
        $request = $this->vaultAccountsPostRequest($vaultAccountsPostRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vaultAccountsPost'
     *
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsPostRequest $vaultAccountsPostRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vaultAccountsPostRequest($vaultAccountsPostRequest, string $contentType = self::contentTypes['vaultAccountsPost'][0])
    {

        // verify the required parameter 'vaultAccountsPostRequest' is set
        if ($vaultAccountsPostRequest === null || (is_array($vaultAccountsPostRequest) && count($vaultAccountsPostRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vaultAccountsPostRequest when calling vaultAccountsPost'
            );
        }


        $resourcePath = '/vault/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($vaultAccountsPostRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($vaultAccountsPostRequest));
            } else {
                $httpBody = $vaultAccountsPostRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdActivatePost
     *
     * Activate a wallet in a vault account.
     *
     * @param  string $vaultAccountId The ID of the vault account to return, or &#39;default&#39; for the default vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdActivatePost'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Developerayo\FireblocksLaravel\Models\CreateVaultAssetResponse|\Developerayo\FireblocksLaravel\Models\Error
     */
    public function vaultAccountsVaultAccountIdAssetIdActivatePost($vaultAccountId, $assetId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdActivatePost'][0])
    {
        list($response) = $this->vaultAccountsVaultAccountIdAssetIdActivatePostWithHttpInfo($vaultAccountId, $assetId, $contentType);
        return $response;
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdActivatePostWithHttpInfo
     *
     * Activate a wallet in a vault account.
     *
     * @param  string $vaultAccountId The ID of the vault account to return, or &#39;default&#39; for the default vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdActivatePost'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Developerayo\FireblocksLaravel\Models\CreateVaultAssetResponse|\Developerayo\FireblocksLaravel\Models\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function vaultAccountsVaultAccountIdAssetIdActivatePostWithHttpInfo($vaultAccountId, $assetId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdActivatePost'][0])
    {
        $request = $this->vaultAccountsVaultAccountIdAssetIdActivatePostRequest($vaultAccountId, $assetId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\CreateVaultAssetResponse',
                        $request,
                        $response,
                    );
                default:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Developerayo\FireblocksLaravel\Models\CreateVaultAssetResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\CreateVaultAssetResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdActivatePostAsync
     *
     * Activate a wallet in a vault account.
     *
     * @param  string $vaultAccountId The ID of the vault account to return, or &#39;default&#39; for the default vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdActivatePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdAssetIdActivatePostAsync($vaultAccountId, $assetId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdActivatePost'][0])
    {
        return $this->vaultAccountsVaultAccountIdAssetIdActivatePostAsyncWithHttpInfo($vaultAccountId, $assetId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdActivatePostAsyncWithHttpInfo
     *
     * Activate a wallet in a vault account.
     *
     * @param  string $vaultAccountId The ID of the vault account to return, or &#39;default&#39; for the default vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdActivatePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdAssetIdActivatePostAsyncWithHttpInfo($vaultAccountId, $assetId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdActivatePost'][0])
    {
        $returnType = '\Developerayo\FireblocksLaravel\Models\CreateVaultAssetResponse';
        $request = $this->vaultAccountsVaultAccountIdAssetIdActivatePostRequest($vaultAccountId, $assetId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vaultAccountsVaultAccountIdAssetIdActivatePost'
     *
     * @param  string $vaultAccountId The ID of the vault account to return, or &#39;default&#39; for the default vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdActivatePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vaultAccountsVaultAccountIdAssetIdActivatePostRequest($vaultAccountId, $assetId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdActivatePost'][0])
    {

        // verify the required parameter 'vaultAccountId' is set
        if ($vaultAccountId === null || (is_array($vaultAccountId) && count($vaultAccountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vaultAccountId when calling vaultAccountsVaultAccountIdAssetIdActivatePost'
            );
        }

        // verify the required parameter 'assetId' is set
        if ($assetId === null || (is_array($assetId) && count($assetId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $assetId when calling vaultAccountsVaultAccountIdAssetIdActivatePost'
            );
        }


        $resourcePath = '/vault/accounts/{vaultAccountId}/{assetId}/activate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($vaultAccountId !== null) {
            $resourcePath = str_replace(
                '{' . 'vaultAccountId' . '}',
                ObjectSerializer::toPathValue($vaultAccountId),
                $resourcePath
            );
        }
        // path params
        if ($assetId !== null) {
            $resourcePath = str_replace(
                '{' . 'assetId' . '}',
                ObjectSerializer::toPathValue($assetId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPost
     *
     * Convert a segwit address to legacy format
     *
     * @param  string $vaultAccountId The ID of the vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $addressId The segwit address to translate (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPost'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Developerayo\FireblocksLaravel\Models\CreateAddressResponse|\Developerayo\FireblocksLaravel\Models\Error
     */
    public function vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPost($vaultAccountId, $assetId, $addressId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPost'][0])
    {
        list($response) = $this->vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPostWithHttpInfo($vaultAccountId, $assetId, $addressId, $contentType);
        return $response;
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPostWithHttpInfo
     *
     * Convert a segwit address to legacy format
     *
     * @param  string $vaultAccountId The ID of the vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $addressId The segwit address to translate (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPost'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Developerayo\FireblocksLaravel\Models\CreateAddressResponse|\Developerayo\FireblocksLaravel\Models\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPostWithHttpInfo($vaultAccountId, $assetId, $addressId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPost'][0])
    {
        $request = $this->vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPostRequest($vaultAccountId, $assetId, $addressId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\CreateAddressResponse',
                        $request,
                        $response,
                    );
                default:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Developerayo\FireblocksLaravel\Models\CreateAddressResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\CreateAddressResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPostAsync
     *
     * Convert a segwit address to legacy format
     *
     * @param  string $vaultAccountId The ID of the vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $addressId The segwit address to translate (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPostAsync($vaultAccountId, $assetId, $addressId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPost'][0])
    {
        return $this->vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPostAsyncWithHttpInfo($vaultAccountId, $assetId, $addressId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPostAsyncWithHttpInfo
     *
     * Convert a segwit address to legacy format
     *
     * @param  string $vaultAccountId The ID of the vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $addressId The segwit address to translate (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPostAsyncWithHttpInfo($vaultAccountId, $assetId, $addressId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPost'][0])
    {
        $returnType = '\Developerayo\FireblocksLaravel\Models\CreateAddressResponse';
        $request = $this->vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPostRequest($vaultAccountId, $assetId, $addressId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPost'
     *
     * @param  string $vaultAccountId The ID of the vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $addressId The segwit address to translate (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPostRequest($vaultAccountId, $assetId, $addressId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPost'][0])
    {

        // verify the required parameter 'vaultAccountId' is set
        if ($vaultAccountId === null || (is_array($vaultAccountId) && count($vaultAccountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vaultAccountId when calling vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPost'
            );
        }

        // verify the required parameter 'assetId' is set
        if ($assetId === null || (is_array($assetId) && count($assetId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $assetId when calling vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPost'
            );
        }

        // verify the required parameter 'addressId' is set
        if ($addressId === null || (is_array($addressId) && count($addressId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $addressId when calling vaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPost'
            );
        }


        $resourcePath = '/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}/create_legacy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($vaultAccountId !== null) {
            $resourcePath = str_replace(
                '{' . 'vaultAccountId' . '}',
                ObjectSerializer::toPathValue($vaultAccountId),
                $resourcePath
            );
        }
        // path params
        if ($assetId !== null) {
            $resourcePath = str_replace(
                '{' . 'assetId' . '}',
                ObjectSerializer::toPathValue($assetId),
                $resourcePath
            );
        }
        // path params
        if ($addressId !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($addressId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPut
     *
     * Update address description
     *
     * @param  string $vaultAccountId The ID of the vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $addressId The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest|null $vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPut'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPut($vaultAccountId, $assetId, $addressId, $vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPut'][0])
    {
        $this->vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutWithHttpInfo($vaultAccountId, $assetId, $addressId, $vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest, $contentType);
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutWithHttpInfo
     *
     * Update address description
     *
     * @param  string $vaultAccountId The ID of the vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $addressId The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest|null $vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPut'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutWithHttpInfo($vaultAccountId, $assetId, $addressId, $vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPut'][0])
    {
        $request = $this->vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest($vaultAccountId, $assetId, $addressId, $vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutAsync
     *
     * Update address description
     *
     * @param  string $vaultAccountId The ID of the vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $addressId The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest|null $vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutAsync($vaultAccountId, $assetId, $addressId, $vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPut'][0])
    {
        return $this->vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutAsyncWithHttpInfo($vaultAccountId, $assetId, $addressId, $vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutAsyncWithHttpInfo
     *
     * Update address description
     *
     * @param  string $vaultAccountId The ID of the vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $addressId The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest|null $vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutAsyncWithHttpInfo($vaultAccountId, $assetId, $addressId, $vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPut'][0])
    {
        $returnType = '';
        $request = $this->vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest($vaultAccountId, $assetId, $addressId, $vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPut'
     *
     * @param  string $vaultAccountId The ID of the vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $addressId The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest|null $vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest($vaultAccountId, $assetId, $addressId, $vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPut'][0])
    {

        // verify the required parameter 'vaultAccountId' is set
        if ($vaultAccountId === null || (is_array($vaultAccountId) && count($vaultAccountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vaultAccountId when calling vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPut'
            );
        }

        // verify the required parameter 'assetId' is set
        if ($assetId === null || (is_array($assetId) && count($assetId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $assetId when calling vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPut'
            );
        }

        // verify the required parameter 'addressId' is set
        if ($addressId === null || (is_array($addressId) && count($addressId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $addressId when calling vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPut'
            );
        }



        $resourcePath = '/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($vaultAccountId !== null) {
            $resourcePath = str_replace(
                '{' . 'vaultAccountId' . '}',
                ObjectSerializer::toPathValue($vaultAccountId),
                $resourcePath
            );
        }
        // path params
        if ($assetId !== null) {
            $resourcePath = str_replace(
                '{' . 'assetId' . '}',
                ObjectSerializer::toPathValue($assetId),
                $resourcePath
            );
        }
        // path params
        if ($addressId !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($addressId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest));
            } else {
                $httpBody = $vaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPost
     *
     * Assign AML customer reference ID
     *
     * @param  string $vaultAccountId The ID of the vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $addressId The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdSetCustomerRefIdPostRequest $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPost'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPost($vaultAccountId, $assetId, $addressId, $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPost'][0])
    {
        $this->vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPostWithHttpInfo($vaultAccountId, $assetId, $addressId, $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest, $contentType);
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPostWithHttpInfo
     *
     * Assign AML customer reference ID
     *
     * @param  string $vaultAccountId The ID of the vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $addressId The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdSetCustomerRefIdPostRequest $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPost'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPostWithHttpInfo($vaultAccountId, $assetId, $addressId, $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPost'][0])
    {
        $request = $this->vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPostRequest($vaultAccountId, $assetId, $addressId, $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPostAsync
     *
     * Assign AML customer reference ID
     *
     * @param  string $vaultAccountId The ID of the vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $addressId The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdSetCustomerRefIdPostRequest $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPostAsync($vaultAccountId, $assetId, $addressId, $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPost'][0])
    {
        return $this->vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPostAsyncWithHttpInfo($vaultAccountId, $assetId, $addressId, $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPostAsyncWithHttpInfo
     *
     * Assign AML customer reference ID
     *
     * @param  string $vaultAccountId The ID of the vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $addressId The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdSetCustomerRefIdPostRequest $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPostAsyncWithHttpInfo($vaultAccountId, $assetId, $addressId, $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPost'][0])
    {
        $returnType = '';
        $request = $this->vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPostRequest($vaultAccountId, $assetId, $addressId, $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPost'
     *
     * @param  string $vaultAccountId The ID of the vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $addressId The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdSetCustomerRefIdPostRequest $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPostRequest($vaultAccountId, $assetId, $addressId, $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPost'][0])
    {

        // verify the required parameter 'vaultAccountId' is set
        if ($vaultAccountId === null || (is_array($vaultAccountId) && count($vaultAccountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vaultAccountId when calling vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPost'
            );
        }

        // verify the required parameter 'assetId' is set
        if ($assetId === null || (is_array($assetId) && count($assetId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $assetId when calling vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPost'
            );
        }

        // verify the required parameter 'addressId' is set
        if ($addressId === null || (is_array($addressId) && count($addressId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $addressId when calling vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPost'
            );
        }

        // verify the required parameter 'vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest' is set
        if ($vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest === null || (is_array($vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest) && count($vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest when calling vaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPost'
            );
        }


        $resourcePath = '/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}/set_customer_ref_id';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($vaultAccountId !== null) {
            $resourcePath = str_replace(
                '{' . 'vaultAccountId' . '}',
                ObjectSerializer::toPathValue($vaultAccountId),
                $resourcePath
            );
        }
        // path params
        if ($assetId !== null) {
            $resourcePath = str_replace(
                '{' . 'assetId' . '}',
                ObjectSerializer::toPathValue($assetId),
                $resourcePath
            );
        }
        // path params
        if ($addressId !== null) {
            $resourcePath = str_replace(
                '{' . 'addressId' . '}',
                ObjectSerializer::toPathValue($addressId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest));
            } else {
                $httpBody = $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdAddressesGet
     *
     * Get asset addresses
     *
     * @param  string $vaultAccountId The ID of the vault account to return (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesGet'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Developerayo\FireblocksLaravel\Models\VaultWalletAddress[]|\Developerayo\FireblocksLaravel\Models\Error
     */
    public function vaultAccountsVaultAccountIdAssetIdAddressesGet($vaultAccountId, $assetId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesGet'][0])
    {
        list($response) = $this->vaultAccountsVaultAccountIdAssetIdAddressesGetWithHttpInfo($vaultAccountId, $assetId, $contentType);
        return $response;
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdAddressesGetWithHttpInfo
     *
     * Get asset addresses
     *
     * @param  string $vaultAccountId The ID of the vault account to return (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesGet'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Developerayo\FireblocksLaravel\Models\VaultWalletAddress[]|\Developerayo\FireblocksLaravel\Models\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function vaultAccountsVaultAccountIdAssetIdAddressesGetWithHttpInfo($vaultAccountId, $assetId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesGet'][0])
    {
        $request = $this->vaultAccountsVaultAccountIdAssetIdAddressesGetRequest($vaultAccountId, $assetId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\VaultWalletAddress[]',
                        $request,
                        $response,
                    );
                default:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Developerayo\FireblocksLaravel\Models\VaultWalletAddress[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\VaultWalletAddress[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdAddressesGetAsync
     *
     * Get asset addresses
     *
     * @param  string $vaultAccountId The ID of the vault account to return (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdAssetIdAddressesGetAsync($vaultAccountId, $assetId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesGet'][0])
    {
        return $this->vaultAccountsVaultAccountIdAssetIdAddressesGetAsyncWithHttpInfo($vaultAccountId, $assetId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdAddressesGetAsyncWithHttpInfo
     *
     * Get asset addresses
     *
     * @param  string $vaultAccountId The ID of the vault account to return (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdAssetIdAddressesGetAsyncWithHttpInfo($vaultAccountId, $assetId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesGet'][0])
    {
        $returnType = '\Developerayo\FireblocksLaravel\Models\VaultWalletAddress[]';
        $request = $this->vaultAccountsVaultAccountIdAssetIdAddressesGetRequest($vaultAccountId, $assetId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vaultAccountsVaultAccountIdAssetIdAddressesGet'
     *
     * @param  string $vaultAccountId The ID of the vault account to return (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vaultAccountsVaultAccountIdAssetIdAddressesGetRequest($vaultAccountId, $assetId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesGet'][0])
    {

        // verify the required parameter 'vaultAccountId' is set
        if ($vaultAccountId === null || (is_array($vaultAccountId) && count($vaultAccountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vaultAccountId when calling vaultAccountsVaultAccountIdAssetIdAddressesGet'
            );
        }

        // verify the required parameter 'assetId' is set
        if ($assetId === null || (is_array($assetId) && count($assetId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $assetId when calling vaultAccountsVaultAccountIdAssetIdAddressesGet'
            );
        }


        $resourcePath = '/vault/accounts/{vaultAccountId}/{assetId}/addresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($vaultAccountId !== null) {
            $resourcePath = str_replace(
                '{' . 'vaultAccountId' . '}',
                ObjectSerializer::toPathValue($vaultAccountId),
                $resourcePath
            );
        }
        // path params
        if ($assetId !== null) {
            $resourcePath = str_replace(
                '{' . 'assetId' . '}',
                ObjectSerializer::toPathValue($assetId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdAddressesPaginatedGet
     *
     * List addresses (Paginated)
     *
     * @param  string $vaultAccountId vaultAccountId (required)
     * @param  string $assetId assetId (required)
     * @param  float|null $limit limit (optional)
     * @param  string|null $before before (optional)
     * @param  string|null $after after (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesPaginatedGet'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Developerayo\FireblocksLaravel\Models\AddressesResponse|\Developerayo\FireblocksLaravel\Models\Error
     */
    public function vaultAccountsVaultAccountIdAssetIdAddressesPaginatedGet($vaultAccountId, $assetId, $limit = null, $before = null, $after = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesPaginatedGet'][0])
    {
        list($response) = $this->vaultAccountsVaultAccountIdAssetIdAddressesPaginatedGetWithHttpInfo($vaultAccountId, $assetId, $limit, $before, $after, $contentType);
        return $response;
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdAddressesPaginatedGetWithHttpInfo
     *
     * List addresses (Paginated)
     *
     * @param  string $vaultAccountId (required)
     * @param  string $assetId (required)
     * @param  float|null $limit (optional)
     * @param  string|null $before (optional)
     * @param  string|null $after (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesPaginatedGet'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Developerayo\FireblocksLaravel\Models\AddressesResponse|\Developerayo\FireblocksLaravel\Models\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function vaultAccountsVaultAccountIdAssetIdAddressesPaginatedGetWithHttpInfo($vaultAccountId, $assetId, $limit = null, $before = null, $after = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesPaginatedGet'][0])
    {
        $request = $this->vaultAccountsVaultAccountIdAssetIdAddressesPaginatedGetRequest($vaultAccountId, $assetId, $limit, $before, $after, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\AddressesResponse',
                        $request,
                        $response,
                    );
                default:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Developerayo\FireblocksLaravel\Models\AddressesResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\AddressesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdAddressesPaginatedGetAsync
     *
     * List addresses (Paginated)
     *
     * @param  string $vaultAccountId (required)
     * @param  string $assetId (required)
     * @param  float|null $limit (optional)
     * @param  string|null $before (optional)
     * @param  string|null $after (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesPaginatedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdAssetIdAddressesPaginatedGetAsync($vaultAccountId, $assetId, $limit = null, $before = null, $after = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesPaginatedGet'][0])
    {
        return $this->vaultAccountsVaultAccountIdAssetIdAddressesPaginatedGetAsyncWithHttpInfo($vaultAccountId, $assetId, $limit, $before, $after, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdAddressesPaginatedGetAsyncWithHttpInfo
     *
     * List addresses (Paginated)
     *
     * @param  string $vaultAccountId (required)
     * @param  string $assetId (required)
     * @param  float|null $limit (optional)
     * @param  string|null $before (optional)
     * @param  string|null $after (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesPaginatedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdAssetIdAddressesPaginatedGetAsyncWithHttpInfo($vaultAccountId, $assetId, $limit = null, $before = null, $after = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesPaginatedGet'][0])
    {
        $returnType = '\Developerayo\FireblocksLaravel\Models\AddressesResponse';
        $request = $this->vaultAccountsVaultAccountIdAssetIdAddressesPaginatedGetRequest($vaultAccountId, $assetId, $limit, $before, $after, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vaultAccountsVaultAccountIdAssetIdAddressesPaginatedGet'
     *
     * @param  string $vaultAccountId (required)
     * @param  string $assetId (required)
     * @param  float|null $limit (optional)
     * @param  string|null $before (optional)
     * @param  string|null $after (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesPaginatedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vaultAccountsVaultAccountIdAssetIdAddressesPaginatedGetRequest($vaultAccountId, $assetId, $limit = null, $before = null, $after = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdAddressesPaginatedGet'][0])
    {

        // verify the required parameter 'vaultAccountId' is set
        if ($vaultAccountId === null || (is_array($vaultAccountId) && count($vaultAccountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vaultAccountId when calling vaultAccountsVaultAccountIdAssetIdAddressesPaginatedGet'
            );
        }

        // verify the required parameter 'assetId' is set
        if ($assetId === null || (is_array($assetId) && count($assetId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $assetId when calling vaultAccountsVaultAccountIdAssetIdAddressesPaginatedGet'
            );
        }





        $resourcePath = '/vault/accounts/{vaultAccountId}/{assetId}/addresses_paginated';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $before,
            'before', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $after,
            'after', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($vaultAccountId !== null) {
            $resourcePath = str_replace(
                '{' . 'vaultAccountId' . '}',
                ObjectSerializer::toPathValue($vaultAccountId),
                $resourcePath
            );
        }
        // path params
        if ($assetId !== null) {
            $resourcePath = str_replace(
                '{' . 'assetId' . '}',
                ObjectSerializer::toPathValue($assetId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdBalancePost
     *
     * Refresh asset balance data
     *
     * @param  string $vaultAccountId The ID of the vault account to return (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  object|null $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdBalancePost'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Developerayo\FireblocksLaravel\Models\VaultAsset|\Developerayo\FireblocksLaravel\Models\Error
     */
    public function vaultAccountsVaultAccountIdAssetIdBalancePost($vaultAccountId, $assetId, $body = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdBalancePost'][0])
    {
        list($response) = $this->vaultAccountsVaultAccountIdAssetIdBalancePostWithHttpInfo($vaultAccountId, $assetId, $body, $contentType);
        return $response;
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdBalancePostWithHttpInfo
     *
     * Refresh asset balance data
     *
     * @param  string $vaultAccountId The ID of the vault account to return (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  object|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdBalancePost'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Developerayo\FireblocksLaravel\Models\VaultAsset|\Developerayo\FireblocksLaravel\Models\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function vaultAccountsVaultAccountIdAssetIdBalancePostWithHttpInfo($vaultAccountId, $assetId, $body = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdBalancePost'][0])
    {
        $request = $this->vaultAccountsVaultAccountIdAssetIdBalancePostRequest($vaultAccountId, $assetId, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\VaultAsset',
                        $request,
                        $response,
                    );
                default:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Developerayo\FireblocksLaravel\Models\VaultAsset',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\VaultAsset',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdBalancePostAsync
     *
     * Refresh asset balance data
     *
     * @param  string $vaultAccountId The ID of the vault account to return (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  object|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdBalancePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdAssetIdBalancePostAsync($vaultAccountId, $assetId, $body = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdBalancePost'][0])
    {
        return $this->vaultAccountsVaultAccountIdAssetIdBalancePostAsyncWithHttpInfo($vaultAccountId, $assetId, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdBalancePostAsyncWithHttpInfo
     *
     * Refresh asset balance data
     *
     * @param  string $vaultAccountId The ID of the vault account to return (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  object|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdBalancePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdAssetIdBalancePostAsyncWithHttpInfo($vaultAccountId, $assetId, $body = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdBalancePost'][0])
    {
        $returnType = '\Developerayo\FireblocksLaravel\Models\VaultAsset';
        $request = $this->vaultAccountsVaultAccountIdAssetIdBalancePostRequest($vaultAccountId, $assetId, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vaultAccountsVaultAccountIdAssetIdBalancePost'
     *
     * @param  string $vaultAccountId The ID of the vault account to return (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  object|null $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdBalancePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vaultAccountsVaultAccountIdAssetIdBalancePostRequest($vaultAccountId, $assetId, $body = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdBalancePost'][0])
    {

        // verify the required parameter 'vaultAccountId' is set
        if ($vaultAccountId === null || (is_array($vaultAccountId) && count($vaultAccountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vaultAccountId when calling vaultAccountsVaultAccountIdAssetIdBalancePost'
            );
        }

        // verify the required parameter 'assetId' is set
        if ($assetId === null || (is_array($assetId) && count($assetId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $assetId when calling vaultAccountsVaultAccountIdAssetIdBalancePost'
            );
        }



        $resourcePath = '/vault/accounts/{vaultAccountId}/{assetId}/balance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($vaultAccountId !== null) {
            $resourcePath = str_replace(
                '{' . 'vaultAccountId' . '}',
                ObjectSerializer::toPathValue($vaultAccountId),
                $resourcePath
            );
        }
        // path params
        if ($assetId !== null) {
            $resourcePath = str_replace(
                '{' . 'assetId' . '}',
                ObjectSerializer::toPathValue($assetId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGet
     *
     * Get the public key for a vault account
     *
     * @param  string $vaultAccountId The ID of the vault account (required)
     * @param  string $assetId The ID of the asset. (required)
     * @param  float $change Whether the address should be derived internal (change) or not. (required)
     * @param  float $addressIndex The index of the address for the derivation path. (required)
     * @param  bool|null $compressed compressed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGet'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Developerayo\FireblocksLaravel\Models\PublicKeyInformation|\Developerayo\FireblocksLaravel\Models\Error
     */
    public function vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGet($vaultAccountId, $assetId, $change, $addressIndex, $compressed = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGet'][0])
    {
        list($response) = $this->vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGetWithHttpInfo($vaultAccountId, $assetId, $change, $addressIndex, $compressed, $contentType);
        return $response;
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGetWithHttpInfo
     *
     * Get the public key for a vault account
     *
     * @param  string $vaultAccountId The ID of the vault account (required)
     * @param  string $assetId The ID of the asset. (required)
     * @param  float $change Whether the address should be derived internal (change) or not. (required)
     * @param  float $addressIndex The index of the address for the derivation path. (required)
     * @param  bool|null $compressed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGet'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Developerayo\FireblocksLaravel\Models\PublicKeyInformation|\Developerayo\FireblocksLaravel\Models\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGetWithHttpInfo($vaultAccountId, $assetId, $change, $addressIndex, $compressed = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGet'][0])
    {
        $request = $this->vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGetRequest($vaultAccountId, $assetId, $change, $addressIndex, $compressed, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\PublicKeyInformation',
                        $request,
                        $response,
                    );
                default:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Developerayo\FireblocksLaravel\Models\PublicKeyInformation',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\PublicKeyInformation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGetAsync
     *
     * Get the public key for a vault account
     *
     * @param  string $vaultAccountId The ID of the vault account (required)
     * @param  string $assetId The ID of the asset. (required)
     * @param  float $change Whether the address should be derived internal (change) or not. (required)
     * @param  float $addressIndex The index of the address for the derivation path. (required)
     * @param  bool|null $compressed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGetAsync($vaultAccountId, $assetId, $change, $addressIndex, $compressed = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGet'][0])
    {
        return $this->vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGetAsyncWithHttpInfo($vaultAccountId, $assetId, $change, $addressIndex, $compressed, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGetAsyncWithHttpInfo
     *
     * Get the public key for a vault account
     *
     * @param  string $vaultAccountId The ID of the vault account (required)
     * @param  string $assetId The ID of the asset. (required)
     * @param  float $change Whether the address should be derived internal (change) or not. (required)
     * @param  float $addressIndex The index of the address for the derivation path. (required)
     * @param  bool|null $compressed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGetAsyncWithHttpInfo($vaultAccountId, $assetId, $change, $addressIndex, $compressed = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGet'][0])
    {
        $returnType = '\Developerayo\FireblocksLaravel\Models\PublicKeyInformation';
        $request = $this->vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGetRequest($vaultAccountId, $assetId, $change, $addressIndex, $compressed, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGet'
     *
     * @param  string $vaultAccountId The ID of the vault account (required)
     * @param  string $assetId The ID of the asset. (required)
     * @param  float $change Whether the address should be derived internal (change) or not. (required)
     * @param  float $addressIndex The index of the address for the derivation path. (required)
     * @param  bool|null $compressed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGetRequest($vaultAccountId, $assetId, $change, $addressIndex, $compressed = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGet'][0])
    {

        // verify the required parameter 'vaultAccountId' is set
        if ($vaultAccountId === null || (is_array($vaultAccountId) && count($vaultAccountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vaultAccountId when calling vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGet'
            );
        }

        // verify the required parameter 'assetId' is set
        if ($assetId === null || (is_array($assetId) && count($assetId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $assetId when calling vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGet'
            );
        }

        // verify the required parameter 'change' is set
        if ($change === null || (is_array($change) && count($change) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $change when calling vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGet'
            );
        }

        // verify the required parameter 'addressIndex' is set
        if ($addressIndex === null || (is_array($addressIndex) && count($addressIndex) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $addressIndex when calling vaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGet'
            );
        }



        $resourcePath = '/vault/accounts/{vaultAccountId}/{assetId}/{change}/{addressIndex}/public_key_info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $compressed,
            'compressed', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($vaultAccountId !== null) {
            $resourcePath = str_replace(
                '{' . 'vaultAccountId' . '}',
                ObjectSerializer::toPathValue($vaultAccountId),
                $resourcePath
            );
        }
        // path params
        if ($assetId !== null) {
            $resourcePath = str_replace(
                '{' . 'assetId' . '}',
                ObjectSerializer::toPathValue($assetId),
                $resourcePath
            );
        }
        // path params
        if ($change !== null) {
            $resourcePath = str_replace(
                '{' . 'change' . '}',
                ObjectSerializer::toPathValue($change),
                $resourcePath
            );
        }
        // path params
        if ($addressIndex !== null) {
            $resourcePath = str_replace(
                '{' . 'addressIndex' . '}',
                ObjectSerializer::toPathValue($addressIndex),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdGet
     *
     * Get the asset balance for a vault account
     *
     * @param  string $vaultAccountId The ID of the vault account to return (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdGet'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Developerayo\FireblocksLaravel\Models\VaultAsset|\Developerayo\FireblocksLaravel\Models\Error
     */
    public function vaultAccountsVaultAccountIdAssetIdGet($vaultAccountId, $assetId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdGet'][0])
    {
        list($response) = $this->vaultAccountsVaultAccountIdAssetIdGetWithHttpInfo($vaultAccountId, $assetId, $contentType);
        return $response;
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdGetWithHttpInfo
     *
     * Get the asset balance for a vault account
     *
     * @param  string $vaultAccountId The ID of the vault account to return (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdGet'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Developerayo\FireblocksLaravel\Models\VaultAsset|\Developerayo\FireblocksLaravel\Models\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function vaultAccountsVaultAccountIdAssetIdGetWithHttpInfo($vaultAccountId, $assetId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdGet'][0])
    {
        $request = $this->vaultAccountsVaultAccountIdAssetIdGetRequest($vaultAccountId, $assetId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\VaultAsset',
                        $request,
                        $response,
                    );
                default:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Developerayo\FireblocksLaravel\Models\VaultAsset',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\VaultAsset',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdGetAsync
     *
     * Get the asset balance for a vault account
     *
     * @param  string $vaultAccountId The ID of the vault account to return (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdAssetIdGetAsync($vaultAccountId, $assetId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdGet'][0])
    {
        return $this->vaultAccountsVaultAccountIdAssetIdGetAsyncWithHttpInfo($vaultAccountId, $assetId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdGetAsyncWithHttpInfo
     *
     * Get the asset balance for a vault account
     *
     * @param  string $vaultAccountId The ID of the vault account to return (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdAssetIdGetAsyncWithHttpInfo($vaultAccountId, $assetId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdGet'][0])
    {
        $returnType = '\Developerayo\FireblocksLaravel\Models\VaultAsset';
        $request = $this->vaultAccountsVaultAccountIdAssetIdGetRequest($vaultAccountId, $assetId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vaultAccountsVaultAccountIdAssetIdGet'
     *
     * @param  string $vaultAccountId The ID of the vault account to return (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vaultAccountsVaultAccountIdAssetIdGetRequest($vaultAccountId, $assetId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdGet'][0])
    {

        // verify the required parameter 'vaultAccountId' is set
        if ($vaultAccountId === null || (is_array($vaultAccountId) && count($vaultAccountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vaultAccountId when calling vaultAccountsVaultAccountIdAssetIdGet'
            );
        }

        // verify the required parameter 'assetId' is set
        if ($assetId === null || (is_array($assetId) && count($assetId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $assetId when calling vaultAccountsVaultAccountIdAssetIdGet'
            );
        }


        $resourcePath = '/vault/accounts/{vaultAccountId}/{assetId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($vaultAccountId !== null) {
            $resourcePath = str_replace(
                '{' . 'vaultAccountId' . '}',
                ObjectSerializer::toPathValue($vaultAccountId),
                $resourcePath
            );
        }
        // path params
        if ($assetId !== null) {
            $resourcePath = str_replace(
                '{' . 'assetId' . '}',
                ObjectSerializer::toPathValue($assetId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGet
     *
     * Get the maximum spendable amount in a single transaction.
     *
     * @param  string $vaultAccountId The ID of the vault account, or &#39;default&#39; for the default vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  bool|null $manualSignging False by default. The maximum number of inputs depends if the transaction will be signed by an automated co-signer server or on a mobile device. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGet'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGet($vaultAccountId, $assetId, $manualSignging = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGet'][0])
    {
        $this->vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGetWithHttpInfo($vaultAccountId, $assetId, $manualSignging, $contentType);
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGetWithHttpInfo
     *
     * Get the maximum spendable amount in a single transaction.
     *
     * @param  string $vaultAccountId The ID of the vault account, or &#39;default&#39; for the default vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  bool|null $manualSignging False by default. The maximum number of inputs depends if the transaction will be signed by an automated co-signer server or on a mobile device. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGet'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGetWithHttpInfo($vaultAccountId, $assetId, $manualSignging = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGet'][0])
    {
        $request = $this->vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGetRequest($vaultAccountId, $assetId, $manualSignging, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGetAsync
     *
     * Get the maximum spendable amount in a single transaction.
     *
     * @param  string $vaultAccountId The ID of the vault account, or &#39;default&#39; for the default vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  bool|null $manualSignging False by default. The maximum number of inputs depends if the transaction will be signed by an automated co-signer server or on a mobile device. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGetAsync($vaultAccountId, $assetId, $manualSignging = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGet'][0])
    {
        return $this->vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGetAsyncWithHttpInfo($vaultAccountId, $assetId, $manualSignging, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGetAsyncWithHttpInfo
     *
     * Get the maximum spendable amount in a single transaction.
     *
     * @param  string $vaultAccountId The ID of the vault account, or &#39;default&#39; for the default vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  bool|null $manualSignging False by default. The maximum number of inputs depends if the transaction will be signed by an automated co-signer server or on a mobile device. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGetAsyncWithHttpInfo($vaultAccountId, $assetId, $manualSignging = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGet'][0])
    {
        $returnType = '';
        $request = $this->vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGetRequest($vaultAccountId, $assetId, $manualSignging, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGet'
     *
     * @param  string $vaultAccountId The ID of the vault account, or &#39;default&#39; for the default vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  bool|null $manualSignging False by default. The maximum number of inputs depends if the transaction will be signed by an automated co-signer server or on a mobile device. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGetRequest($vaultAccountId, $assetId, $manualSignging = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGet'][0])
    {

        // verify the required parameter 'vaultAccountId' is set
        if ($vaultAccountId === null || (is_array($vaultAccountId) && count($vaultAccountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vaultAccountId when calling vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGet'
            );
        }

        // verify the required parameter 'assetId' is set
        if ($assetId === null || (is_array($assetId) && count($assetId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $assetId when calling vaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGet'
            );
        }



        $resourcePath = '/vault/accounts/{vaultAccountId}/{assetId}/max_spendable_amount';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $manualSignging,
            'manualSignging', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($vaultAccountId !== null) {
            $resourcePath = str_replace(
                '{' . 'vaultAccountId' . '}',
                ObjectSerializer::toPathValue($vaultAccountId),
                $resourcePath
            );
        }
        // path params
        if ($assetId !== null) {
            $resourcePath = str_replace(
                '{' . 'assetId' . '}',
                ObjectSerializer::toPathValue($assetId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdPost
     *
     * Create a new wallet
     *
     * @param  string $vaultAccountId The ID of the vault account to return, or &#39;default&#39; for the default vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdAssetIdPostRequest|null $vaultAccountsVaultAccountIdAssetIdPostRequest vaultAccountsVaultAccountIdAssetIdPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdPost'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Developerayo\FireblocksLaravel\Models\CreateVaultAssetResponse|\Developerayo\FireblocksLaravel\Models\Error
     */
    public function vaultAccountsVaultAccountIdAssetIdPost($vaultAccountId, $assetId, $vaultAccountsVaultAccountIdAssetIdPostRequest = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdPost'][0])
    {
        list($response) = $this->vaultAccountsVaultAccountIdAssetIdPostWithHttpInfo($vaultAccountId, $assetId, $vaultAccountsVaultAccountIdAssetIdPostRequest, $contentType);
        return $response;
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdPostWithHttpInfo
     *
     * Create a new wallet
     *
     * @param  string $vaultAccountId The ID of the vault account to return, or &#39;default&#39; for the default vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdAssetIdPostRequest|null $vaultAccountsVaultAccountIdAssetIdPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdPost'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Developerayo\FireblocksLaravel\Models\CreateVaultAssetResponse|\Developerayo\FireblocksLaravel\Models\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function vaultAccountsVaultAccountIdAssetIdPostWithHttpInfo($vaultAccountId, $assetId, $vaultAccountsVaultAccountIdAssetIdPostRequest = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdPost'][0])
    {
        $request = $this->vaultAccountsVaultAccountIdAssetIdPostRequest($vaultAccountId, $assetId, $vaultAccountsVaultAccountIdAssetIdPostRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\CreateVaultAssetResponse',
                        $request,
                        $response,
                    );
                default:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Developerayo\FireblocksLaravel\Models\CreateVaultAssetResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\CreateVaultAssetResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdPostAsync
     *
     * Create a new wallet
     *
     * @param  string $vaultAccountId The ID of the vault account to return, or &#39;default&#39; for the default vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdAssetIdPostRequest|null $vaultAccountsVaultAccountIdAssetIdPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdAssetIdPostAsync($vaultAccountId, $assetId, $vaultAccountsVaultAccountIdAssetIdPostRequest = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdPost'][0])
    {
        return $this->vaultAccountsVaultAccountIdAssetIdPostAsyncWithHttpInfo($vaultAccountId, $assetId, $vaultAccountsVaultAccountIdAssetIdPostRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdPostAsyncWithHttpInfo
     *
     * Create a new wallet
     *
     * @param  string $vaultAccountId The ID of the vault account to return, or &#39;default&#39; for the default vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdAssetIdPostRequest|null $vaultAccountsVaultAccountIdAssetIdPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdAssetIdPostAsyncWithHttpInfo($vaultAccountId, $assetId, $vaultAccountsVaultAccountIdAssetIdPostRequest = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdPost'][0])
    {
        $returnType = '\Developerayo\FireblocksLaravel\Models\CreateVaultAssetResponse';
        $request = $this->vaultAccountsVaultAccountIdAssetIdPostRequest($vaultAccountId, $assetId, $vaultAccountsVaultAccountIdAssetIdPostRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vaultAccountsVaultAccountIdAssetIdPost'
     *
     * @param  string $vaultAccountId The ID of the vault account to return, or &#39;default&#39; for the default vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdAssetIdPostRequest|null $vaultAccountsVaultAccountIdAssetIdPostRequest (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vaultAccountsVaultAccountIdAssetIdPostRequest($vaultAccountId, $assetId, $vaultAccountsVaultAccountIdAssetIdPostRequest = null, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdPost'][0])
    {

        // verify the required parameter 'vaultAccountId' is set
        if ($vaultAccountId === null || (is_array($vaultAccountId) && count($vaultAccountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vaultAccountId when calling vaultAccountsVaultAccountIdAssetIdPost'
            );
        }

        // verify the required parameter 'assetId' is set
        if ($assetId === null || (is_array($assetId) && count($assetId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $assetId when calling vaultAccountsVaultAccountIdAssetIdPost'
            );
        }



        $resourcePath = '/vault/accounts/{vaultAccountId}/{assetId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($vaultAccountId !== null) {
            $resourcePath = str_replace(
                '{' . 'vaultAccountId' . '}',
                ObjectSerializer::toPathValue($vaultAccountId),
                $resourcePath
            );
        }
        // path params
        if ($assetId !== null) {
            $resourcePath = str_replace(
                '{' . 'assetId' . '}',
                ObjectSerializer::toPathValue($assetId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($vaultAccountsVaultAccountIdAssetIdPostRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($vaultAccountsVaultAccountIdAssetIdPostRequest));
            } else {
                $httpBody = $vaultAccountsVaultAccountIdAssetIdPostRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdUnspentInputsGet
     *
     * Get UTXO unspent inputs information
     *
     * @param  string $vaultAccountId The ID of the vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdUnspentInputsGet'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Developerayo\FireblocksLaravel\Models\UnspentInputsResponse[]|\Developerayo\FireblocksLaravel\Models\Error
     */
    public function vaultAccountsVaultAccountIdAssetIdUnspentInputsGet($vaultAccountId, $assetId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdUnspentInputsGet'][0])
    {
        list($response) = $this->vaultAccountsVaultAccountIdAssetIdUnspentInputsGetWithHttpInfo($vaultAccountId, $assetId, $contentType);
        return $response;
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdUnspentInputsGetWithHttpInfo
     *
     * Get UTXO unspent inputs information
     *
     * @param  string $vaultAccountId The ID of the vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdUnspentInputsGet'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Developerayo\FireblocksLaravel\Models\UnspentInputsResponse[]|\Developerayo\FireblocksLaravel\Models\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function vaultAccountsVaultAccountIdAssetIdUnspentInputsGetWithHttpInfo($vaultAccountId, $assetId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdUnspentInputsGet'][0])
    {
        $request = $this->vaultAccountsVaultAccountIdAssetIdUnspentInputsGetRequest($vaultAccountId, $assetId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\UnspentInputsResponse[]',
                        $request,
                        $response,
                    );
                default:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Developerayo\FireblocksLaravel\Models\UnspentInputsResponse[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\UnspentInputsResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdUnspentInputsGetAsync
     *
     * Get UTXO unspent inputs information
     *
     * @param  string $vaultAccountId The ID of the vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdUnspentInputsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdAssetIdUnspentInputsGetAsync($vaultAccountId, $assetId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdUnspentInputsGet'][0])
    {
        return $this->vaultAccountsVaultAccountIdAssetIdUnspentInputsGetAsyncWithHttpInfo($vaultAccountId, $assetId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vaultAccountsVaultAccountIdAssetIdUnspentInputsGetAsyncWithHttpInfo
     *
     * Get UTXO unspent inputs information
     *
     * @param  string $vaultAccountId The ID of the vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdUnspentInputsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdAssetIdUnspentInputsGetAsyncWithHttpInfo($vaultAccountId, $assetId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdUnspentInputsGet'][0])
    {
        $returnType = '\Developerayo\FireblocksLaravel\Models\UnspentInputsResponse[]';
        $request = $this->vaultAccountsVaultAccountIdAssetIdUnspentInputsGetRequest($vaultAccountId, $assetId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vaultAccountsVaultAccountIdAssetIdUnspentInputsGet'
     *
     * @param  string $vaultAccountId The ID of the vault account (required)
     * @param  string $assetId The ID of the asset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdAssetIdUnspentInputsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vaultAccountsVaultAccountIdAssetIdUnspentInputsGetRequest($vaultAccountId, $assetId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdAssetIdUnspentInputsGet'][0])
    {

        // verify the required parameter 'vaultAccountId' is set
        if ($vaultAccountId === null || (is_array($vaultAccountId) && count($vaultAccountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vaultAccountId when calling vaultAccountsVaultAccountIdAssetIdUnspentInputsGet'
            );
        }

        // verify the required parameter 'assetId' is set
        if ($assetId === null || (is_array($assetId) && count($assetId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $assetId when calling vaultAccountsVaultAccountIdAssetIdUnspentInputsGet'
            );
        }


        $resourcePath = '/vault/accounts/{vaultAccountId}/{assetId}/unspent_inputs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($vaultAccountId !== null) {
            $resourcePath = str_replace(
                '{' . 'vaultAccountId' . '}',
                ObjectSerializer::toPathValue($vaultAccountId),
                $resourcePath
            );
        }
        // path params
        if ($assetId !== null) {
            $resourcePath = str_replace(
                '{' . 'assetId' . '}',
                ObjectSerializer::toPathValue($assetId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vaultAccountsVaultAccountIdGet
     *
     * Find a vault account by ID
     *
     * @param  string $vaultAccountId The ID of the vault account to return type: string (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdGet'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Developerayo\FireblocksLaravel\Models\VaultAccount|\Developerayo\FireblocksLaravel\Models\Error
     */
    public function vaultAccountsVaultAccountIdGet($vaultAccountId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdGet'][0])
    {
        list($response) = $this->vaultAccountsVaultAccountIdGetWithHttpInfo($vaultAccountId, $contentType);
        return $response;
    }

    /**
     * Operation vaultAccountsVaultAccountIdGetWithHttpInfo
     *
     * Find a vault account by ID
     *
     * @param  string $vaultAccountId The ID of the vault account to return type: string (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdGet'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Developerayo\FireblocksLaravel\Models\VaultAccount|\Developerayo\FireblocksLaravel\Models\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function vaultAccountsVaultAccountIdGetWithHttpInfo($vaultAccountId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdGet'][0])
    {
        $request = $this->vaultAccountsVaultAccountIdGetRequest($vaultAccountId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\VaultAccount',
                        $request,
                        $response,
                    );
                default:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Developerayo\FireblocksLaravel\Models\VaultAccount',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\VaultAccount',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation vaultAccountsVaultAccountIdGetAsync
     *
     * Find a vault account by ID
     *
     * @param  string $vaultAccountId The ID of the vault account to return type: string (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdGetAsync($vaultAccountId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdGet'][0])
    {
        return $this->vaultAccountsVaultAccountIdGetAsyncWithHttpInfo($vaultAccountId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vaultAccountsVaultAccountIdGetAsyncWithHttpInfo
     *
     * Find a vault account by ID
     *
     * @param  string $vaultAccountId The ID of the vault account to return type: string (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdGetAsyncWithHttpInfo($vaultAccountId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdGet'][0])
    {
        $returnType = '\Developerayo\FireblocksLaravel\Models\VaultAccount';
        $request = $this->vaultAccountsVaultAccountIdGetRequest($vaultAccountId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vaultAccountsVaultAccountIdGet'
     *
     * @param  string $vaultAccountId The ID of the vault account to return type: string (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vaultAccountsVaultAccountIdGetRequest($vaultAccountId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdGet'][0])
    {

        // verify the required parameter 'vaultAccountId' is set
        if ($vaultAccountId === null || (is_array($vaultAccountId) && count($vaultAccountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vaultAccountId when calling vaultAccountsVaultAccountIdGet'
            );
        }


        $resourcePath = '/vault/accounts/{vaultAccountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($vaultAccountId !== null) {
            $resourcePath = str_replace(
                '{' . 'vaultAccountId' . '}',
                ObjectSerializer::toPathValue($vaultAccountId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vaultAccountsVaultAccountIdHidePost
     *
     * Hide a vault account in the console
     *
     * @param  string $vaultAccountId The vault account to hide (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdHidePost'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vaultAccountsVaultAccountIdHidePost($vaultAccountId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdHidePost'][0])
    {
        $this->vaultAccountsVaultAccountIdHidePostWithHttpInfo($vaultAccountId, $contentType);
    }

    /**
     * Operation vaultAccountsVaultAccountIdHidePostWithHttpInfo
     *
     * Hide a vault account in the console
     *
     * @param  string $vaultAccountId The vault account to hide (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdHidePost'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vaultAccountsVaultAccountIdHidePostWithHttpInfo($vaultAccountId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdHidePost'][0])
    {
        $request = $this->vaultAccountsVaultAccountIdHidePostRequest($vaultAccountId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation vaultAccountsVaultAccountIdHidePostAsync
     *
     * Hide a vault account in the console
     *
     * @param  string $vaultAccountId The vault account to hide (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdHidePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdHidePostAsync($vaultAccountId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdHidePost'][0])
    {
        return $this->vaultAccountsVaultAccountIdHidePostAsyncWithHttpInfo($vaultAccountId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vaultAccountsVaultAccountIdHidePostAsyncWithHttpInfo
     *
     * Hide a vault account in the console
     *
     * @param  string $vaultAccountId The vault account to hide (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdHidePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdHidePostAsyncWithHttpInfo($vaultAccountId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdHidePost'][0])
    {
        $returnType = '';
        $request = $this->vaultAccountsVaultAccountIdHidePostRequest($vaultAccountId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vaultAccountsVaultAccountIdHidePost'
     *
     * @param  string $vaultAccountId The vault account to hide (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdHidePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vaultAccountsVaultAccountIdHidePostRequest($vaultAccountId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdHidePost'][0])
    {

        // verify the required parameter 'vaultAccountId' is set
        if ($vaultAccountId === null || (is_array($vaultAccountId) && count($vaultAccountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vaultAccountId when calling vaultAccountsVaultAccountIdHidePost'
            );
        }
        

        $resourcePath = '/vault/accounts/{vaultAccountId}/hide';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($vaultAccountId !== null) {
            $resourcePath = str_replace(
                '{' . 'vaultAccountId' . '}',
                ObjectSerializer::toPathValue($vaultAccountId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vaultAccountsVaultAccountIdPut
     *
     * Rename a vault account
     *
     * @param  string $vaultAccountId The ID of the vault account to edit (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdPutRequest $vaultAccountsVaultAccountIdPutRequest vaultAccountsVaultAccountIdPutRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdPut'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vaultAccountsVaultAccountIdPut($vaultAccountId, $vaultAccountsVaultAccountIdPutRequest, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdPut'][0])
    {
        $this->vaultAccountsVaultAccountIdPutWithHttpInfo($vaultAccountId, $vaultAccountsVaultAccountIdPutRequest, $contentType);
    }

    /**
     * Operation vaultAccountsVaultAccountIdPutWithHttpInfo
     *
     * Rename a vault account
     *
     * @param  string $vaultAccountId The ID of the vault account to edit (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdPutRequest $vaultAccountsVaultAccountIdPutRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdPut'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vaultAccountsVaultAccountIdPutWithHttpInfo($vaultAccountId, $vaultAccountsVaultAccountIdPutRequest, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdPut'][0])
    {
        $request = $this->vaultAccountsVaultAccountIdPutRequest($vaultAccountId, $vaultAccountsVaultAccountIdPutRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation vaultAccountsVaultAccountIdPutAsync
     *
     * Rename a vault account
     *
     * @param  string $vaultAccountId The ID of the vault account to edit (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdPutRequest $vaultAccountsVaultAccountIdPutRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdPutAsync($vaultAccountId, $vaultAccountsVaultAccountIdPutRequest, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdPut'][0])
    {
        return $this->vaultAccountsVaultAccountIdPutAsyncWithHttpInfo($vaultAccountId, $vaultAccountsVaultAccountIdPutRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vaultAccountsVaultAccountIdPutAsyncWithHttpInfo
     *
     * Rename a vault account
     *
     * @param  string $vaultAccountId The ID of the vault account to edit (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdPutRequest $vaultAccountsVaultAccountIdPutRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdPutAsyncWithHttpInfo($vaultAccountId, $vaultAccountsVaultAccountIdPutRequest, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdPut'][0])
    {
        $returnType = '';
        $request = $this->vaultAccountsVaultAccountIdPutRequest($vaultAccountId, $vaultAccountsVaultAccountIdPutRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vaultAccountsVaultAccountIdPut'
     *
     * @param  string $vaultAccountId The ID of the vault account to edit (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdPutRequest $vaultAccountsVaultAccountIdPutRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vaultAccountsVaultAccountIdPutRequest($vaultAccountId, $vaultAccountsVaultAccountIdPutRequest, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdPut'][0])
    {

        // verify the required parameter 'vaultAccountId' is set
        if ($vaultAccountId === null || (is_array($vaultAccountId) && count($vaultAccountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vaultAccountId when calling vaultAccountsVaultAccountIdPut'
            );
        }

        // verify the required parameter 'vaultAccountsVaultAccountIdPutRequest' is set
        if ($vaultAccountsVaultAccountIdPutRequest === null || (is_array($vaultAccountsVaultAccountIdPutRequest) && count($vaultAccountsVaultAccountIdPutRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vaultAccountsVaultAccountIdPutRequest when calling vaultAccountsVaultAccountIdPut'
            );
        }


        $resourcePath = '/vault/accounts/{vaultAccountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($vaultAccountId !== null) {
            $resourcePath = str_replace(
                '{' . 'vaultAccountId' . '}',
                ObjectSerializer::toPathValue($vaultAccountId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($vaultAccountsVaultAccountIdPutRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($vaultAccountsVaultAccountIdPutRequest));
            } else {
                $httpBody = $vaultAccountsVaultAccountIdPutRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vaultAccountsVaultAccountIdSetAutoFuelPost
     *
     * Turn autofueling on or off
     *
     * @param  string $vaultAccountId The vault account ID (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdSetAutoFuelPostRequest $vaultAccountsVaultAccountIdSetAutoFuelPostRequest vaultAccountsVaultAccountIdSetAutoFuelPostRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdSetAutoFuelPost'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vaultAccountsVaultAccountIdSetAutoFuelPost($vaultAccountId, $vaultAccountsVaultAccountIdSetAutoFuelPostRequest, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdSetAutoFuelPost'][0])
    {
        $this->vaultAccountsVaultAccountIdSetAutoFuelPostWithHttpInfo($vaultAccountId, $vaultAccountsVaultAccountIdSetAutoFuelPostRequest, $contentType);
    }

    /**
     * Operation vaultAccountsVaultAccountIdSetAutoFuelPostWithHttpInfo
     *
     * Turn autofueling on or off
     *
     * @param  string $vaultAccountId The vault account ID (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdSetAutoFuelPostRequest $vaultAccountsVaultAccountIdSetAutoFuelPostRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdSetAutoFuelPost'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vaultAccountsVaultAccountIdSetAutoFuelPostWithHttpInfo($vaultAccountId, $vaultAccountsVaultAccountIdSetAutoFuelPostRequest, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdSetAutoFuelPost'][0])
    {
        $request = $this->vaultAccountsVaultAccountIdSetAutoFuelPostRequest($vaultAccountId, $vaultAccountsVaultAccountIdSetAutoFuelPostRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation vaultAccountsVaultAccountIdSetAutoFuelPostAsync
     *
     * Turn autofueling on or off
     *
     * @param  string $vaultAccountId The vault account ID (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdSetAutoFuelPostRequest $vaultAccountsVaultAccountIdSetAutoFuelPostRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdSetAutoFuelPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdSetAutoFuelPostAsync($vaultAccountId, $vaultAccountsVaultAccountIdSetAutoFuelPostRequest, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdSetAutoFuelPost'][0])
    {
        return $this->vaultAccountsVaultAccountIdSetAutoFuelPostAsyncWithHttpInfo($vaultAccountId, $vaultAccountsVaultAccountIdSetAutoFuelPostRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vaultAccountsVaultAccountIdSetAutoFuelPostAsyncWithHttpInfo
     *
     * Turn autofueling on or off
     *
     * @param  string $vaultAccountId The vault account ID (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdSetAutoFuelPostRequest $vaultAccountsVaultAccountIdSetAutoFuelPostRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdSetAutoFuelPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdSetAutoFuelPostAsyncWithHttpInfo($vaultAccountId, $vaultAccountsVaultAccountIdSetAutoFuelPostRequest, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdSetAutoFuelPost'][0])
    {
        $returnType = '';
        $request = $this->vaultAccountsVaultAccountIdSetAutoFuelPostRequest($vaultAccountId, $vaultAccountsVaultAccountIdSetAutoFuelPostRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vaultAccountsVaultAccountIdSetAutoFuelPost'
     *
     * @param  string $vaultAccountId The vault account ID (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdSetAutoFuelPostRequest $vaultAccountsVaultAccountIdSetAutoFuelPostRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdSetAutoFuelPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vaultAccountsVaultAccountIdSetAutoFuelPostRequest($vaultAccountId, $vaultAccountsVaultAccountIdSetAutoFuelPostRequest, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdSetAutoFuelPost'][0])
    {

        // verify the required parameter 'vaultAccountId' is set
        if ($vaultAccountId === null || (is_array($vaultAccountId) && count($vaultAccountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vaultAccountId when calling vaultAccountsVaultAccountIdSetAutoFuelPost'
            );
        }
        
        // verify the required parameter 'vaultAccountsVaultAccountIdSetAutoFuelPostRequest' is set
        if ($vaultAccountsVaultAccountIdSetAutoFuelPostRequest === null || (is_array($vaultAccountsVaultAccountIdSetAutoFuelPostRequest) && count($vaultAccountsVaultAccountIdSetAutoFuelPostRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vaultAccountsVaultAccountIdSetAutoFuelPostRequest when calling vaultAccountsVaultAccountIdSetAutoFuelPost'
            );
        }


        $resourcePath = '/vault/accounts/{vaultAccountId}/set_auto_fuel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($vaultAccountId !== null) {
            $resourcePath = str_replace(
                '{' . 'vaultAccountId' . '}',
                ObjectSerializer::toPathValue($vaultAccountId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($vaultAccountsVaultAccountIdSetAutoFuelPostRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($vaultAccountsVaultAccountIdSetAutoFuelPostRequest));
            } else {
                $httpBody = $vaultAccountsVaultAccountIdSetAutoFuelPostRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vaultAccountsVaultAccountIdSetCustomerRefIdPost
     *
     * Set an AML/KYT customer reference ID for a vault account
     *
     * @param  string $vaultAccountId The vault account ID (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdSetCustomerRefIdPostRequest $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdSetCustomerRefIdPost'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vaultAccountsVaultAccountIdSetCustomerRefIdPost($vaultAccountId, $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdSetCustomerRefIdPost'][0])
    {
        $this->vaultAccountsVaultAccountIdSetCustomerRefIdPostWithHttpInfo($vaultAccountId, $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest, $contentType);
    }

    /**
     * Operation vaultAccountsVaultAccountIdSetCustomerRefIdPostWithHttpInfo
     *
     * Set an AML/KYT customer reference ID for a vault account
     *
     * @param  string $vaultAccountId The vault account ID (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdSetCustomerRefIdPostRequest $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdSetCustomerRefIdPost'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vaultAccountsVaultAccountIdSetCustomerRefIdPostWithHttpInfo($vaultAccountId, $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdSetCustomerRefIdPost'][0])
    {
        $request = $this->vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest($vaultAccountId, $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation vaultAccountsVaultAccountIdSetCustomerRefIdPostAsync
     *
     * Set an AML/KYT customer reference ID for a vault account
     *
     * @param  string $vaultAccountId The vault account ID (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdSetCustomerRefIdPostRequest $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdSetCustomerRefIdPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdSetCustomerRefIdPostAsync($vaultAccountId, $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdSetCustomerRefIdPost'][0])
    {
        return $this->vaultAccountsVaultAccountIdSetCustomerRefIdPostAsyncWithHttpInfo($vaultAccountId, $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vaultAccountsVaultAccountIdSetCustomerRefIdPostAsyncWithHttpInfo
     *
     * Set an AML/KYT customer reference ID for a vault account
     *
     * @param  string $vaultAccountId The vault account ID (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdSetCustomerRefIdPostRequest $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdSetCustomerRefIdPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdSetCustomerRefIdPostAsyncWithHttpInfo($vaultAccountId, $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdSetCustomerRefIdPost'][0])
    {
        $returnType = '';
        $request = $this->vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest($vaultAccountId, $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vaultAccountsVaultAccountIdSetCustomerRefIdPost'
     *
     * @param  string $vaultAccountId The vault account ID (required)
     * @param  \Developerayo\FireblocksLaravel\Models\VaultAccountsVaultAccountIdSetCustomerRefIdPostRequest $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdSetCustomerRefIdPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest($vaultAccountId, $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdSetCustomerRefIdPost'][0])
    {

        // verify the required parameter 'vaultAccountId' is set
        if ($vaultAccountId === null || (is_array($vaultAccountId) && count($vaultAccountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vaultAccountId when calling vaultAccountsVaultAccountIdSetCustomerRefIdPost'
            );
        }
        
        // verify the required parameter 'vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest' is set
        if ($vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest === null || (is_array($vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest) && count($vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest when calling vaultAccountsVaultAccountIdSetCustomerRefIdPost'
            );
        }


        $resourcePath = '/vault/accounts/{vaultAccountId}/set_customer_ref_id';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($vaultAccountId !== null) {
            $resourcePath = str_replace(
                '{' . 'vaultAccountId' . '}',
                ObjectSerializer::toPathValue($vaultAccountId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest));
            } else {
                $httpBody = $vaultAccountsVaultAccountIdSetCustomerRefIdPostRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vaultAccountsVaultAccountIdUnhidePost
     *
     * Unhide a vault account in the console
     *
     * @param  string $vaultAccountId The vault account to unhide (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdUnhidePost'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function vaultAccountsVaultAccountIdUnhidePost($vaultAccountId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdUnhidePost'][0])
    {
        $this->vaultAccountsVaultAccountIdUnhidePostWithHttpInfo($vaultAccountId, $contentType);
    }

    /**
     * Operation vaultAccountsVaultAccountIdUnhidePostWithHttpInfo
     *
     * Unhide a vault account in the console
     *
     * @param  string $vaultAccountId The vault account to unhide (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdUnhidePost'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function vaultAccountsVaultAccountIdUnhidePostWithHttpInfo($vaultAccountId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdUnhidePost'][0])
    {
        $request = $this->vaultAccountsVaultAccountIdUnhidePostRequest($vaultAccountId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation vaultAccountsVaultAccountIdUnhidePostAsync
     *
     * Unhide a vault account in the console
     *
     * @param  string $vaultAccountId The vault account to unhide (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdUnhidePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdUnhidePostAsync($vaultAccountId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdUnhidePost'][0])
    {
        return $this->vaultAccountsVaultAccountIdUnhidePostAsyncWithHttpInfo($vaultAccountId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vaultAccountsVaultAccountIdUnhidePostAsyncWithHttpInfo
     *
     * Unhide a vault account in the console
     *
     * @param  string $vaultAccountId The vault account to unhide (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdUnhidePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAccountsVaultAccountIdUnhidePostAsyncWithHttpInfo($vaultAccountId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdUnhidePost'][0])
    {
        $returnType = '';
        $request = $this->vaultAccountsVaultAccountIdUnhidePostRequest($vaultAccountId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vaultAccountsVaultAccountIdUnhidePost'
     *
     * @param  string $vaultAccountId The vault account to unhide (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAccountsVaultAccountIdUnhidePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vaultAccountsVaultAccountIdUnhidePostRequest($vaultAccountId, string $contentType = self::contentTypes['vaultAccountsVaultAccountIdUnhidePost'][0])
    {

        // verify the required parameter 'vaultAccountId' is set
        if ($vaultAccountId === null || (is_array($vaultAccountId) && count($vaultAccountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vaultAccountId when calling vaultAccountsVaultAccountIdUnhidePost'
            );
        }
        

        $resourcePath = '/vault/accounts/{vaultAccountId}/unhide';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($vaultAccountId !== null) {
            $resourcePath = str_replace(
                '{' . 'vaultAccountId' . '}',
                ObjectSerializer::toPathValue($vaultAccountId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vaultAssetWalletsGet
     *
     * List asset wallets (Paginated)
     *
     * @param  float|null $totalAmountLargerThan When specified, only asset wallets with total balance larger than this amount are returned. (optional)
     * @param  string|null $assetId When specified, only asset wallets cross vault accounts that have this asset ID are returned. (optional)
     * @param  string|null $orderBy orderBy (optional, default to 'DESC')
     * @param  string|null $before Fetches the next paginated response before this element. This element is a cursor and is returned at the response of the previous page. (optional)
     * @param  string|null $after Fetches the next paginated response after this element. This element is a cursor and is returned at the response of the previous page. (optional)
     * @param  float|null $limit The maximum number of asset wallets in a single response. The default is 200 and the maximum is 1000. (optional, default to 200)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAssetWalletsGet'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Developerayo\FireblocksLaravel\Models\PaginatedAssetWalletResponse
     */
    public function vaultAssetWalletsGet($totalAmountLargerThan = null, $assetId = null, $orderBy = 'DESC', $before = null, $after = null, $limit = 200, string $contentType = self::contentTypes['vaultAssetWalletsGet'][0])
    {
        list($response) = $this->vaultAssetWalletsGetWithHttpInfo($totalAmountLargerThan, $assetId, $orderBy, $before, $after, $limit, $contentType);
        return $response;
    }

    /**
     * Operation vaultAssetWalletsGetWithHttpInfo
     *
     * List asset wallets (Paginated)
     *
     * @param  float|null $totalAmountLargerThan When specified, only asset wallets with total balance larger than this amount are returned. (optional)
     * @param  string|null $assetId When specified, only asset wallets cross vault accounts that have this asset ID are returned. (optional)
     * @param  string|null $orderBy (optional, default to 'DESC')
     * @param  string|null $before Fetches the next paginated response before this element. This element is a cursor and is returned at the response of the previous page. (optional)
     * @param  string|null $after Fetches the next paginated response after this element. This element is a cursor and is returned at the response of the previous page. (optional)
     * @param  float|null $limit The maximum number of asset wallets in a single response. The default is 200 and the maximum is 1000. (optional, default to 200)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAssetWalletsGet'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Developerayo\FireblocksLaravel\Models\PaginatedAssetWalletResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function vaultAssetWalletsGetWithHttpInfo($totalAmountLargerThan = null, $assetId = null, $orderBy = 'DESC', $before = null, $after = null, $limit = 200, string $contentType = self::contentTypes['vaultAssetWalletsGet'][0])
    {
        $request = $this->vaultAssetWalletsGetRequest($totalAmountLargerThan, $assetId, $orderBy, $before, $after, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\PaginatedAssetWalletResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Developerayo\FireblocksLaravel\Models\PaginatedAssetWalletResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\PaginatedAssetWalletResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation vaultAssetWalletsGetAsync
     *
     * List asset wallets (Paginated)
     *
     * @param  float|null $totalAmountLargerThan When specified, only asset wallets with total balance larger than this amount are returned. (optional)
     * @param  string|null $assetId When specified, only asset wallets cross vault accounts that have this asset ID are returned. (optional)
     * @param  string|null $orderBy (optional, default to 'DESC')
     * @param  string|null $before Fetches the next paginated response before this element. This element is a cursor and is returned at the response of the previous page. (optional)
     * @param  string|null $after Fetches the next paginated response after this element. This element is a cursor and is returned at the response of the previous page. (optional)
     * @param  float|null $limit The maximum number of asset wallets in a single response. The default is 200 and the maximum is 1000. (optional, default to 200)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAssetWalletsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAssetWalletsGetAsync($totalAmountLargerThan = null, $assetId = null, $orderBy = 'DESC', $before = null, $after = null, $limit = 200, string $contentType = self::contentTypes['vaultAssetWalletsGet'][0])
    {
        return $this->vaultAssetWalletsGetAsyncWithHttpInfo($totalAmountLargerThan, $assetId, $orderBy, $before, $after, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vaultAssetWalletsGetAsyncWithHttpInfo
     *
     * List asset wallets (Paginated)
     *
     * @param  float|null $totalAmountLargerThan When specified, only asset wallets with total balance larger than this amount are returned. (optional)
     * @param  string|null $assetId When specified, only asset wallets cross vault accounts that have this asset ID are returned. (optional)
     * @param  string|null $orderBy (optional, default to 'DESC')
     * @param  string|null $before Fetches the next paginated response before this element. This element is a cursor and is returned at the response of the previous page. (optional)
     * @param  string|null $after Fetches the next paginated response after this element. This element is a cursor and is returned at the response of the previous page. (optional)
     * @param  float|null $limit The maximum number of asset wallets in a single response. The default is 200 and the maximum is 1000. (optional, default to 200)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAssetWalletsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAssetWalletsGetAsyncWithHttpInfo($totalAmountLargerThan = null, $assetId = null, $orderBy = 'DESC', $before = null, $after = null, $limit = 200, string $contentType = self::contentTypes['vaultAssetWalletsGet'][0])
    {
        $returnType = '\Developerayo\FireblocksLaravel\Models\PaginatedAssetWalletResponse';
        $request = $this->vaultAssetWalletsGetRequest($totalAmountLargerThan, $assetId, $orderBy, $before, $after, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vaultAssetWalletsGet'
     *
     * @param  float|null $totalAmountLargerThan When specified, only asset wallets with total balance larger than this amount are returned. (optional)
     * @param  string|null $assetId When specified, only asset wallets cross vault accounts that have this asset ID are returned. (optional)
     * @param  string|null $orderBy (optional, default to 'DESC')
     * @param  string|null $before Fetches the next paginated response before this element. This element is a cursor and is returned at the response of the previous page. (optional)
     * @param  string|null $after Fetches the next paginated response after this element. This element is a cursor and is returned at the response of the previous page. (optional)
     * @param  float|null $limit The maximum number of asset wallets in a single response. The default is 200 and the maximum is 1000. (optional, default to 200)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAssetWalletsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vaultAssetWalletsGetRequest($totalAmountLargerThan = null, $assetId = null, $orderBy = 'DESC', $before = null, $after = null, $limit = 200, string $contentType = self::contentTypes['vaultAssetWalletsGet'][0])
    {






        if ($limit !== null && $limit > 1000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling VaultsApi.vaultAssetWalletsGet, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling VaultsApi.vaultAssetWalletsGet, must be bigger than or equal to 1.');
        }
        

        $resourcePath = '/vault/asset_wallets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $totalAmountLargerThan,
            'totalAmountLargerThan', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assetId,
            'assetId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderBy,
            'orderBy', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $before,
            'before', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $after,
            'after', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vaultAssetsAssetIdGet
     *
     * Get vault balance by asset
     *
     * @param  string $assetId assetId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAssetsAssetIdGet'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Developerayo\FireblocksLaravel\Models\VaultAsset|\Developerayo\FireblocksLaravel\Models\Error
     */
    public function vaultAssetsAssetIdGet($assetId, string $contentType = self::contentTypes['vaultAssetsAssetIdGet'][0])
    {
        list($response) = $this->vaultAssetsAssetIdGetWithHttpInfo($assetId, $contentType);
        return $response;
    }

    /**
     * Operation vaultAssetsAssetIdGetWithHttpInfo
     *
     * Get vault balance by asset
     *
     * @param  string $assetId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAssetsAssetIdGet'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Developerayo\FireblocksLaravel\Models\VaultAsset|\Developerayo\FireblocksLaravel\Models\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function vaultAssetsAssetIdGetWithHttpInfo($assetId, string $contentType = self::contentTypes['vaultAssetsAssetIdGet'][0])
    {
        $request = $this->vaultAssetsAssetIdGetRequest($assetId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\VaultAsset',
                        $request,
                        $response,
                    );
                default:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Developerayo\FireblocksLaravel\Models\VaultAsset',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\VaultAsset',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation vaultAssetsAssetIdGetAsync
     *
     * Get vault balance by asset
     *
     * @param  string $assetId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAssetsAssetIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAssetsAssetIdGetAsync($assetId, string $contentType = self::contentTypes['vaultAssetsAssetIdGet'][0])
    {
        return $this->vaultAssetsAssetIdGetAsyncWithHttpInfo($assetId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vaultAssetsAssetIdGetAsyncWithHttpInfo
     *
     * Get vault balance by asset
     *
     * @param  string $assetId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAssetsAssetIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAssetsAssetIdGetAsyncWithHttpInfo($assetId, string $contentType = self::contentTypes['vaultAssetsAssetIdGet'][0])
    {
        $returnType = '\Developerayo\FireblocksLaravel\Models\VaultAsset';
        $request = $this->vaultAssetsAssetIdGetRequest($assetId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vaultAssetsAssetIdGet'
     *
     * @param  string $assetId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAssetsAssetIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vaultAssetsAssetIdGetRequest($assetId, string $contentType = self::contentTypes['vaultAssetsAssetIdGet'][0])
    {

        // verify the required parameter 'assetId' is set
        if ($assetId === null || (is_array($assetId) && count($assetId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $assetId when calling vaultAssetsAssetIdGet'
            );
        }


        $resourcePath = '/vault/assets/{assetId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($assetId !== null) {
            $resourcePath = str_replace(
                '{' . 'assetId' . '}',
                ObjectSerializer::toPathValue($assetId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vaultAssetsGet
     *
     * Get asset balance for chosen assets
     *
     * @param  string|null $accountNamePrefix accountNamePrefix (optional)
     * @param  string|null $accountNameSuffix accountNameSuffix (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAssetsGet'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Developerayo\FireblocksLaravel\Models\VaultAsset[]|\Developerayo\FireblocksLaravel\Models\Error
     */
    public function vaultAssetsGet($accountNamePrefix = null, $accountNameSuffix = null, string $contentType = self::contentTypes['vaultAssetsGet'][0])
    {
        list($response) = $this->vaultAssetsGetWithHttpInfo($accountNamePrefix, $accountNameSuffix, $contentType);
        return $response;
    }

    /**
     * Operation vaultAssetsGetWithHttpInfo
     *
     * Get asset balance for chosen assets
     *
     * @param  string|null $accountNamePrefix (optional)
     * @param  string|null $accountNameSuffix (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAssetsGet'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Developerayo\FireblocksLaravel\Models\VaultAsset[]|\Developerayo\FireblocksLaravel\Models\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function vaultAssetsGetWithHttpInfo($accountNamePrefix = null, $accountNameSuffix = null, string $contentType = self::contentTypes['vaultAssetsGet'][0])
    {
        $request = $this->vaultAssetsGetRequest($accountNamePrefix, $accountNameSuffix, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\VaultAsset[]',
                        $request,
                        $response,
                    );
                default:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Developerayo\FireblocksLaravel\Models\VaultAsset[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\VaultAsset[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation vaultAssetsGetAsync
     *
     * Get asset balance for chosen assets
     *
     * @param  string|null $accountNamePrefix (optional)
     * @param  string|null $accountNameSuffix (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAssetsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAssetsGetAsync($accountNamePrefix = null, $accountNameSuffix = null, string $contentType = self::contentTypes['vaultAssetsGet'][0])
    {
        return $this->vaultAssetsGetAsyncWithHttpInfo($accountNamePrefix, $accountNameSuffix, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vaultAssetsGetAsyncWithHttpInfo
     *
     * Get asset balance for chosen assets
     *
     * @param  string|null $accountNamePrefix (optional)
     * @param  string|null $accountNameSuffix (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAssetsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultAssetsGetAsyncWithHttpInfo($accountNamePrefix = null, $accountNameSuffix = null, string $contentType = self::contentTypes['vaultAssetsGet'][0])
    {
        $returnType = '\Developerayo\FireblocksLaravel\Models\VaultAsset[]';
        $request = $this->vaultAssetsGetRequest($accountNamePrefix, $accountNameSuffix, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vaultAssetsGet'
     *
     * @param  string|null $accountNamePrefix (optional)
     * @param  string|null $accountNameSuffix (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultAssetsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vaultAssetsGetRequest($accountNamePrefix = null, $accountNameSuffix = null, string $contentType = self::contentTypes['vaultAssetsGet'][0])
    {




        $resourcePath = '/vault/assets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $accountNamePrefix,
            'accountNamePrefix', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $accountNameSuffix,
            'accountNameSuffix', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vaultPublicKeyInfoGet
     *
     * Get the public key information
     *
     * @param  int[] $derivationPath An array of integers representing the full BIP44 derivation path of the requested public key.  The first element must always be 44. (required)
     * @param  string $algorithm algorithm (required)
     * @param  bool|null $compressed compressed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultPublicKeyInfoGet'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Developerayo\FireblocksLaravel\Models\PublicKeyInformation|\Developerayo\FireblocksLaravel\Models\Error
     */
    public function vaultPublicKeyInfoGet($derivationPath, $algorithm, $compressed = null, string $contentType = self::contentTypes['vaultPublicKeyInfoGet'][0])
    {
        list($response) = $this->vaultPublicKeyInfoGetWithHttpInfo($derivationPath, $algorithm, $compressed, $contentType);
        return $response;
    }

    /**
     * Operation vaultPublicKeyInfoGetWithHttpInfo
     *
     * Get the public key information
     *
     * @param  int[] $derivationPath An array of integers representing the full BIP44 derivation path of the requested public key.  The first element must always be 44. (required)
     * @param  string $algorithm (required)
     * @param  bool|null $compressed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultPublicKeyInfoGet'] to see the possible values for this operation
     *
     * @throws \Developerayo\FireblocksLaravel\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Developerayo\FireblocksLaravel\Models\PublicKeyInformation|\Developerayo\FireblocksLaravel\Models\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function vaultPublicKeyInfoGetWithHttpInfo($derivationPath, $algorithm, $compressed = null, string $contentType = self::contentTypes['vaultPublicKeyInfoGet'][0])
    {
        $request = $this->vaultPublicKeyInfoGetRequest($derivationPath, $algorithm, $compressed, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\PublicKeyInformation',
                        $request,
                        $response,
                    );
                default:
                    return $this->handleResponseWithDataType(
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Developerayo\FireblocksLaravel\Models\PublicKeyInformation',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\PublicKeyInformation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Developerayo\FireblocksLaravel\Models\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation vaultPublicKeyInfoGetAsync
     *
     * Get the public key information
     *
     * @param  int[] $derivationPath An array of integers representing the full BIP44 derivation path of the requested public key.  The first element must always be 44. (required)
     * @param  string $algorithm (required)
     * @param  bool|null $compressed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultPublicKeyInfoGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultPublicKeyInfoGetAsync($derivationPath, $algorithm, $compressed = null, string $contentType = self::contentTypes['vaultPublicKeyInfoGet'][0])
    {
        return $this->vaultPublicKeyInfoGetAsyncWithHttpInfo($derivationPath, $algorithm, $compressed, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vaultPublicKeyInfoGetAsyncWithHttpInfo
     *
     * Get the public key information
     *
     * @param  int[] $derivationPath An array of integers representing the full BIP44 derivation path of the requested public key.  The first element must always be 44. (required)
     * @param  string $algorithm (required)
     * @param  bool|null $compressed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultPublicKeyInfoGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vaultPublicKeyInfoGetAsyncWithHttpInfo($derivationPath, $algorithm, $compressed = null, string $contentType = self::contentTypes['vaultPublicKeyInfoGet'][0])
    {
        $returnType = '\Developerayo\FireblocksLaravel\Models\PublicKeyInformation';
        $request = $this->vaultPublicKeyInfoGetRequest($derivationPath, $algorithm, $compressed, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vaultPublicKeyInfoGet'
     *
     * @param  int[] $derivationPath An array of integers representing the full BIP44 derivation path of the requested public key.  The first element must always be 44. (required)
     * @param  string $algorithm (required)
     * @param  bool|null $compressed (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['vaultPublicKeyInfoGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function vaultPublicKeyInfoGetRequest($derivationPath, $algorithm, $compressed = null, string $contentType = self::contentTypes['vaultPublicKeyInfoGet'][0])
    {

        // verify the required parameter 'derivationPath' is set
        if ($derivationPath === null || (is_array($derivationPath) && count($derivationPath) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $derivationPath when calling vaultPublicKeyInfoGet'
            );
        }
        if (count($derivationPath) > 5) {
            throw new \InvalidArgumentException('invalid value for "$derivationPath" when calling VaultsApi.vaultPublicKeyInfoGet, number of items must be less than or equal to 5.');
        }
        if (count($derivationPath) < 5) {
            throw new \InvalidArgumentException('invalid value for "$derivationPath" when calling VaultsApi.vaultPublicKeyInfoGet, number of items must be greater than or equal to 5.');
        }
        
        // verify the required parameter 'algorithm' is set
        if ($algorithm === null || (is_array($algorithm) && count($algorithm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $algorithm when calling vaultPublicKeyInfoGet'
            );
        }



        $resourcePath = '/vault/public_key_info/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $derivationPath,
            'derivationPath', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $algorithm,
            'algorithm', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $compressed,
            'compressed', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
